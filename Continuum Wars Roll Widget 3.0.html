<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Continuum Wars Roll Widget</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>const { jsPDF } = window.jspdf;</script>
  <style>
    @import url('https://fonts.cdnfonts.com/css/orbitron');
    body {
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(135deg, #0a0a23, #1a1a3a);
      color: #e0e0ff;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 1170px;
      margin: 20px auto;
      padding: 20px;
      background: rgba(15, 15, 40, 0.9);
      border: 2px solid #00ffcc;
      border-radius: 10px;
      box-shadow: 0 0 15px #00cc99;
    }
    h1 {
      font-size: 2rem;
      text-align: center;
      color: #00ffcc;
      text-shadow: 0 0 5px #00cc99;
      margin-bottom: 1.5rem;
    }
    h2 {
      font-size: 1.3rem;
      color: #ffcc00;
      text-shadow: 0 0 3px #ff9900;
      margin-bottom: 0.75rem;
    }
    .input-section, .results, .history, .gm-reference, .character-sheet {
      background: rgba(20, 20, 50, 0.8);
      padding: 1.5rem;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      border: 1px solid #00ffcc;
    }
    .gm-reference.collapsed .gm-content, .character-sheet.collapsed .sheet-content {
      display: none;
    }
    .toggle-button {
      background: linear-gradient(90deg, #ffcc00, #ff9900);
      padding: 0.6rem;
      border-radius: 5px;
      cursor: pointer;
      text-align: center;
      margin-bottom: 1rem;
    }
    .toggle-button:hover {
      background: linear-gradient(90deg, #ff9900, #ffcc00);
      transform: scale(1.05);
    }
    .grid {
      display: grid;
      gap: 1rem;
      grid-template-columns: 1fr;
    }
    @media (min-width: 768px) {
      .grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    label {
      display: block;
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.3rem;
    }
    select, input, textarea {
      width: 100%;
      padding: 0.6rem;
      border: 1px solid #00cc99;
      border-radius: 5px;
      background: #1a1a3a;
      color: #e0e0ff;
    }
    button {
      width: 100%;
      padding: 0.7rem;
      background: linear-gradient(90deg, #00ffcc, #00cc99);
      color: #0a0a23;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s;
    }
    button:hover {
      transform: scale(1.05);
      background: linear-gradient(90deg, #00cc99, #00ffcc);
    }
    .dynamic-button, .add-button, .reroll-button {
      background: linear-gradient(90deg, #ffcc00, #ff9900);
      margin: 5px;
      padding: 0.6rem;
      font-size: 0.9rem;
      width: auto;
    }
    .dynamic-button:hover, .add-button:hover, .reroll-button:hover {
      background: linear-gradient(90deg, #ff9900, #ffcc00);
    }
    .remove-button {
      background: linear-gradient(90deg, #ff4444, #cc0000);
      padding: 0.6rem;
      width: auto;
    }
    .remove-button:hover {
      background: linear-gradient(90deg, #cc0000, #ff4444);
    }
    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }
    .hidden {
      display: none;
    }
    ul {
      padding-left: 1.5rem;
      list-style-type: square;
      color: #ffcc00;
    }
    p {
      margin: 0.3rem 0;
      line-height: 1.4;
    }
    .critical { color: #00ffcc; font-weight: bold; text-shadow: 0 0 3px #00cc99; }
    .sanity { color: #ff66cc; font-weight: bold; text-shadow: 0 0 3px #ff3399; }
    .paradox { color: #ff4444; font-weight: bold; text-shadow: 0 0 3px #cc0000; }
    .level-note { color: #ffcc00; font-style: italic; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #00cc99;
      padding: 8px;
      text-align: left;
      color: #e0e0ff;
    }
    th { background: #1a1a3a; }
    .dynamic-group {
      display: flex;
      gap: 1rem;
      margin-bottom: 0.5rem;
      align-items: center;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background: rgba(15, 15, 40, 0.9);
      border: 2px solid #00ffcc;
      border-radius: 10px;
      padding: 20px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
    }
    .close-button {
      float: right;
      cursor: pointer;
      color: #ff4444;
      font-size: 1.5rem;
    }
    .sheet-preview {
      font-size: 12pt;
      line-height: 1.6;
    }
    .sheet-preview h2 { font-size: 18pt; }
    .copyable-text {
      width: 100%;
      height: 200px;
      margin-top: 10px;
    }
    .advantage-warning {
      color: #ff4444;
      margin-bottom: 10px;
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
  <h1>Continuum Wars Roll Widget</h1>
  <div class="input-section">
  <h2>Configure Your Roll</h2>
  <div class="grid">
    <div>
      <label>Character Level</label>
      <input id="characterLevel" type="number" value="1" min="1" max="15" placeholder="Level (1-15)" title="Character's level" onchange="updateInputs(); updateFeats(); updateClassAbilities();">
    </div>
    <div>
      <label>Character Class</label>
      <select id="characterClass" title="Character's class" onchange="updateInputs(); updateFeats(); updateClassAbilities();">
        <option value="Fatemarked">Fatemarked</option>
        <option value="Biomatrix Suit">Biomatrix Suit</option>
        <option value="Continuum Raider">Continuum Raider</option>
        <option value="Gunrunner">Gunrunner</option>
        <option value="Faterunner">Faterunner</option>
        <option value="Harlequin">Harlequin</option>
        <option value="Warrior">Warrior</option>
        <option value="Mage">Mage</option>
        <option value="Shape">Shape</option>
        <option value="Masque">Masque</option>
        <option value="Adventurer">Adventurer</option>
      </select>
    </div>
    <div>
      <label>Roll Type</label>
      <select id="rollType" title="Type of dice roll" onchange="resetInputs(); updateInputs(); updateSkillSpecOptions();">
        <option value="skill">Skill Check (d20 + Modifier + Rank)</option>
        <option value="attack">Attack Roll (d20 + BAB + Modifier vs. AC)</option>
        <option value="damage">Damage Roll (Dice + Modifier)</option>
        <option value="sanity">Sanity Check (d20 + WIS Modifier)</option>
        <option value="saving">Saving Throw (d20 + Modifier)</option>
        <option value="initiative">Initiative (d20 + DEX Modifier)</option>
        <option value="paradox">Paradox Risk Check (d20 + Modifier)</option>
        <option value="hazard">Environmental Hazard Roll (d20 + Modifier)</option>
        <option value="custom">Custom Roll (e.g., 3d6)</option>
        <option value="extended">Extended Test (Cumulative DC)</option>
        <option value="opposed">Opposed Test (d20 + Modifier vs. Opponent)</option>
        <option value="extendedOpposed">Extended Opposed Test</option>
        <option value="disarm">Disarm (Attack Roll vs. AC)</option>
        <option value="grapple">Grapple (Opposed Check)</option>
        <option value="trip">Trip (Attack Roll vs. AC)</option>
        <option value="nonLethal">Non-Lethal Damage (Dice + Modifier)</option>
      </select>
    </div>
    <div id="damageDiceInput" class="hidden">
      <label>Damage Dice</label>
      <select id="damageDice" title="Dice for damage roll">
        <option value="1d4">1d4</option>
        <option value="1d6">1d6</option>
        <option value="1d8">1d8</option>
        <option value="2d6">2d6</option>
        <option value="1d10">1d10</option>
        <option value="2d8">2d8</option>
      </select>
    </div>
    <div id="customDiceInput" class="hidden">
      <label>Custom Dice</label>
      <input id="customDice" type="text" placeholder="e.g., 3d6" title="Custom dice notation (e.g., 3d6)">
    </div>
    <div>
      <label>Modifier (Attribute)</label>
      <input id="modifier" type="number" value="0" placeholder="Modifier" title="Attribute modifier">
    </div>
    <div id="skillRankInput" class="hidden">
      <label>Skill Rank</label>
      <input id="skillRank" type="number" value="0" min="0" placeholder="Rank" title="Skill rank">
    </div>
    <div id="babInput" class="hidden">
      <label>Base Attack Bonus (BAB)</label>
      <input id="bab" type="number" value="0" min="0" placeholder="BAB" title="Base Attack Bonus">
    </div>
    <div id="savingTypeInput" class="hidden">
      <label>Saving Throw Type</label>
      <select id="savingType" title="Type of saving throw">
        <option value="reflex">Reflex (DEX)</option>
        <option value="fortitude">Fortitude (CON)</option>
        <option value="willpower">Willpower (WIS)</option>
        <option value="luck">Luck (CHA, Level 4+)</option>
      </select>
    </div>
    <div id="paradoxDCInput" class="hidden">
      <label>Paradox DC</label>
      <select id="paradoxDC" title="Paradox Difficulty Class" onchange="updateParadoxDC()">
        <option value="custom">Custom DC</option>
        <option value="15">PL 1 (DC 15)</option>
        <option value="18">PL 2 (DC 18)</option>
        <option value="22">PL 3 (DC 22)</option>
      </select>
      <input id="customParadoxDC" type="number" placeholder="Custom DC" title="Custom Paradox DC" class="hidden">
    </div>
    <div id="powerLevelInput" class="hidden">
      <label>Power Level/Tier</label>
      <select id="powerLevel" title="Power level for paradox risk"></select>
    </div>
    <div id="dcInput" class="hidden">
      <label>Difficulty Class (DC)</label>
      <input id="dc" type="number" placeholder="DC (e.g., 15)" min="0" title="Difficulty Class">
    </div>
    <div id="acInput" class="hidden">
      <label>Target Armor Class (AC)</label>
      <input id="ac" type="number" value="15" min="0" placeholder="AC" title="Target Armor Class">
    </div>
    <div id="opponentRollInput" class="hidden">
      <label>Opponent Roll</label>
      <input id="opponentRoll" type="number" value="0" min="0" placeholder="Opponent Roll" title="Opponent's roll for opposed tests">
    </div>
    <div id="cumulativeDCInput" class="hidden">
      <label>Cumulative DC</label>
      <input id="cumulativeDC" type="number" placeholder="DC (e.g., 30)" min="0" title="Cumulative DC for extended tests">
    </div>
    <div id="skillNameInput" class="hidden">
      <label>Skill Name</label>
      <select id="skillName" title="Skill for the roll" onchange="updateSkillSpecOptions()">
        <option value="none">Select Skill</option>
      </select>
    </div>
    <div id="skillSpecInput" class="hidden">
      <label>Skill Specialization</label>
      <select id="skillSpec" title="Specialization for the skill">
        <option value="none">None</option>
      </select>
    </div>
    <div id="advantageSelectInput" class="hidden">
      <label>Advantage</label>
      <select id="advantageSelect" title="Select advantage">
        <option value="none">None</option>
      </select>
      <input id="advantageTier" type="number" min="1" max="5" value="1" style="width: 100px;" placeholder="Tier" title="Advantage tier" class="hidden">
    </div>
    <div id="disadvantageSelectInput" class="hidden">
      <label>Disadvantage</label>
      <select id="disadvantageSelect" title="Select disadvantage">
        <option value="none">None</option>
      </select>
      <input id="disadvantageTier" type="number" min="1" max="5" value="1" style="width: 100px;" placeholder="Tier" title="Disadvantage tier" class="hidden">
    </div>
    <div id="powerSelectInput" class="hidden">
      <label>Power</label>
      <select id="powerSelect" title="Select power">
        <option value="none">None</option>
      </select>
    </div>
    <div>
      <label>Class Feat/Advantage</label>
      <select id="classFeat" class="feat-select" title="Class-relevant feat or advantage" onchange="updateInputs(); updateFeatOptions()">
        <option value="none">None</option>
      </select>
      <div id="classFeatTierInput" class="hidden">
        <label>Feat/Advantage Tier</label>
        <input id="classFeatTier" type="number" min="1" max="5" value="1" placeholder="Tier" title="Feat or advantage tier">
      </div>
      <div id="featContainer"></div>
      <button class="add-button" onclick="addFeatField()">Add Feat/Advantage</button>
    </div>
    <div>
      <label>Mechanical Advantage</label>
      <select id="advantage" title="Mechanical advantage or disadvantage">
        <option value="none">None</option>
        <option value="advantage">Advantage</option>
        <option value="disadvantage">Disadvantage</option>
      </select>
    </div>
    <div>
      <label>Environmental Advantage (GM)</label>
      <input type="checkbox" id="envAdvantage" title="Grant environmental advantage">
      <label for="envAdvantage">Grant Advantage</label>
    </div>
    <div id="paradoxCheckInput" class="hidden">
      <label>Elective Paradox Check (Faterunner/Harlequin)</label>
      <input type="checkbox" id="paradoxCheckOptIn" title="Opt-in for paradox check on Tier 2/3 effects">
      <label for="paradoxCheckOptIn">Apply Paradox Check</label>
    </div>
    <div id="synergyBonusInput" class="hidden">
      <label>Synergy Bonus</label>
      <input type="checkbox" id="synergyBonus" title="Apply +2 bonus from allies"> Apply +2 Bonus
    </div>
    <div id="coverConcealmentInput" class="hidden">
      <label>Cover/Concealment</label>
      <select id="coverConcealment" title="Cover or concealment modifiers">
        <option value="none">None</option>
        <option value="cover">Cover (+4 AC)</option>
        <option value="concealment">Concealment (20% miss)</option>
      </select>
    </div>
    <div id="customFeatInput" class="hidden">
      <label>Custom Feat Description</label>
      <input id="customFeat" type="text" placeholder="Describe custom feat" title="Description of custom feat">
    </div>
    <div id="rollFormulaInput" class="hidden">
      <label>Roll Formula</label>
      <input id="rollFormula" type="text" readonly title="Calculated roll formula">
    </div>
  </div>
  <div id="classAbilities">
    <h2>Class Abilities</h2>
    <div id="abilitiesContainer"></div>
  </div>
  <div class="button-group">
    <button onclick="rollDice()">Roll the Dice of Destiny</button>
    <button onclick="clearFields()">Clear Fields</button>
  </div>
</div>

  <div class="gm-reference collapsed">
    <div class="toggle-button" onclick="toggleGMReference()">Show GM Reference</div>
    <div class="gm-content">
      <h2>GM Reference</h2>
      <div>
        <button class="dynamic-button" onclick="generateReality()">Generate Wondrous Reality</button>
        <button class="dynamic-button" onclick="displayTable('attributeModifiers')">Attribute Modifiers</button>
        <button class="dynamic-button" onclick="displayTable('combatDCs')">Combat DCs</button>
        <button class="dynamic-button" onclick="displayTable('sanityDCs')">Sanity DCs</button>
        <button class="dynamic-button" onclick="displayTable('paradoxConsequences')">Paradox Consequences</button>
        <button class="dynamic-button" onclick="displayTable('powerCreation')">Power Creation Costs</button>
        <button class="dynamic-button" onclick="displayTable('levelCaps')">Level Caps</button>
        <button class="dynamic-button" onclick="displayTable('fatemarkedAbilities')">Fatemarked Abilities</button>
        <button class="dynamic-button" onclick="displayTable('challengeRatings')">Challenge Ratings</button>
        <button class="dynamic-button" onclick="displayTable('classResources')">Class Resources</button>
        <button class="dynamic-button" onclick="generateFixedPoint()">Generate Fixed Point</button>
      </div>
      <div id="gmReferenceOutput"></div>
    </div>
  </div>

  <div class="character-sheet collapsed">
    <div class="toggle-button" onclick="toggleCharacterSheet()">Show Character Sheet Generator</div>
    <div class="sheet-content">
    <h2>Character Sheet Generator</h2>
    <div class="grid">
      <div>
        <label>Character Name</label>
        <input id="charName" type="text" placeholder="e.g., Kael Vortex" title="Your character's name" onchange="">
      </div>
      <div>
        <label>Player Name</label>
        <input id="playerName" type="text" placeholder="e.g., Alex" title="Your name as the player">
      </div>
      <div>
        <label>Level</label>
        <input id="charLevel" type="number" value="1" min="1" max="15" placeholder="Level (1-15)" title="Character's current level (1-15)" onchange="updateSheetInputs({ preserveAttributes: true }); updateInputs(); updateSkillSpecOptions(); updateFeats(); updateClassAbilities()">
      </div>
      <div>
        <label>Class</label>
        <select id="charClass" title="Character's class" onchange="updateSheetInputs({ preserveAttributes: true }); updateInputs(); updateSkillSpecOptions(); updateFeats(); updateClassAbilities()">
          <option value="Fatemarked">Fatemarked</option>
          <option value="Biomatrix Suit">Biomatrix Suit</option>
          <option value="Continuum Raider">Continuum Raider</option>
          <option value="Gunrunner">Gunrunner</option>
          <option value="Faterunner">Faterunner</option>
          <option value="Harlequin">Harlequin</option>
          <option value="Warrior">Warrior</option>
          <option value="Mage">Mage</option>
          <option value="Shape">Shape</option>
          <option value="Masque">Masque</option>
          <option value="Adventurer">Adventurer</option>
        </select>
      </div>
      <div>
        <label>Primordial Alignment</label>
        <select id="charAlignment" title="Character's alignment (None for Levels 1-3)">
          <option value="None">None (Levels 1–3)</option>
          <option value="Balance">Balance</option>
          <option value="Chaos">Chaos</option>
          <option value="Order">Order</option>
          <option value="Neutrality">Neutrality</option>
        </select>
      </div>
      <div>
        <label>Background</label>
        <input id="charBackground" type="text" placeholder="e.g., Rift Survivor" title="Character's backstory or origin">
      </div>
      <div>
        <label>Appearance</label>
        <input id="charAppearance" type="text" placeholder="e.g., Cybernetic eye, blue cloak" title="Physical description of the character">
      </div>
      <div>
        <label>Occupation</label>
        <input id="charOccupation" type="text" placeholder="e.g., Rift Navigator" title="Character's profession or role">
      </div>
      <div>
        <label>Personality & Motivation</label>
        <textarea id="charPersonality" placeholder="e.g., Curious, seeks to seal rifts" title="Character's personality traits and goals"></textarea>
      </div>
      <div>
        <label>Narrative Milestone</label>
        <input id="charMilestone" type="text" placeholder="e.g., Sealed first rift" title="Significant event in character's story">
      </div>
    </div>
    <h2>Attributes</h2>
    <div class="grid">
      <div>
        <label>Attribute Method</label>
        <select id="attrMethod" title="Method for generating attributes" onchange="updateAttributes()">
          <option value="pointBuy">Point Buy (15 points)</option>
          <option value="random">Random (4d6 drop lowest)</option>
          <option value="imported" hidden>Imported</option>
        </select>
      </div>
      <div id="rerollButton" class="hidden">
        <button class="reroll-button" onclick="rerollAttributes()">Re-roll Attributes</button>
      </div>
      <div>
        <label>Points Remaining</label>
        <input id="pointsRemaining" type="text" value="15" readonly title="Remaining points for point buy">
      </div>
      <div id="randomRolls" class="hidden">
        <label>Random Rolls</label>
        <input id="rolledStats" type="text" readonly placeholder="Rolled stats appear here" title="Results of random attribute rolls">
      </div>
      <div>
        <label>Strength (STR)</label>
        <input id="attrSTR" type="number" min="1" max="20" value="10" placeholder="STR (8-18)" title="Strength score (8-18)" onchange="updatePoints(); updateSheetInputs({ preserveAttributes: true }); updateInputs()">
        <select id="assignSTR" class="hidden" title="Assign rolled stat to Strength" onchange="assignStat('STR')"></select>
      </div>
      <div>
        <label>Dexterity (DEX)</label>
        <input id="attrDEX" type="number" min="1" max="20" value="10" placeholder="DEX (8-18)" title="Dexterity score (8-18)" onchange="updatePoints(); updateSheetInputs({ preserveAttributes: true }); updateInputs()">
        <select id="assignDEX" class="hidden" title="Assign rolled stat to Dexterity" onchange="assignStat('DEX')"></select>
      </div>
      <div>
        <label>Constitution (CON)</label>
        <input id="attrCON" type="number" min="1" max="20" value="10" placeholder="CON (8-18)" title="Constitution score (8-18)" onchange="updatePoints(); updateSheetInputs({ preserveAttributes: true }); updateInputs()">
        <select id="assignCON" class="hidden" title="Assign rolled stat to Constitution" onchange="assignStat('CON')"></select>
      </div>
      <div>
        <label>Intelligence (INT)</label>
        <input id="attrINT" type="number" min="1" max="20" value="10" placeholder="INT (8-18)" title="Intelligence score (8-18)" onchange="updatePoints(); updateSheetInputs({ preserveAttributes: true }); updateInputs()">
        <select id="assignINT" class="hidden" title="Assign rolled stat to Intelligence" onchange="assignStat('INT')"></select>
      </div>
      <div>
        <label>Wisdom (WIS)</label>
        <input id="attrWIS" type="number" min="1" max="20" value="10" placeholder="WIS (8-18)" title="Wisdom score (8-18)" onchange="updatePoints(); updateSheetInputs({ preserveAttributes: true }); updateInputs()">
        <select id="assignWIS" class="hidden" title="Assign rolled stat to Wisdom" onchange="assignStat('WIS')"></select>
      </div>
      <div>
        <label>Charisma (CHA)</label>
        <input id="attrCHA" type="number" min="1" max="20" value="10" placeholder="CHA (8-18)" title="Charisma score (8-18)" onchange="updatePoints(); updateSheetInputs({ preserveAttributes: true }); updateInputs()">
        <select id="assignCHA" class="hidden" title="Assign rolled stat to Charisma" onchange="assignStat('CHA')"></select>
      </div>
      <div id="confirmAssignments" class="hidden">
        <button class="dynamic-button" onclick="assignStats()">Confirm Assignments</button>
      </div>
    </div>
    <h2>Derived Stats</h2>
    <div class="grid">
      <div>
        <label>Health (Max HP)</label>
        <input id="health" type="number" readonly title="Maximum hit points based on CON and level">
      </div>
      <div>
        <label>Sanity (Mental Resilience)</label>
        <input id="sanity" type="number" readonly title="Mental resilience based on WIS">
      </div>
      <div>
        <label>Defense (AC)</label>
        <input id="defense" type="number" readonly title="Armor Class based on DEX and armor">
      </div>
      <div>
        <label>Initiative Base</label>
        <input id="initiative" type="number" readonly title="Initiative bonus based on DEX">
      </div>
      <div>
        <label>Base Attack Rating (BAB)</label>
        <input id="charBAB" type="number" readonly title="Base Attack Bonus for attacks">
      </div>
      <div>
        <label>Speed (ft/round)</label>
        <input id="speed" type="number" value="30" readonly title="Movement speed in feet per round">
      </div>
      <div>
        <label>Reflex Save</label>
        <input id="reflex" type="number" readonly title="Reflex save based on DEX">
      </div>
      <div>
        <label>Fortitude Save</label>
        <input id="fortitude" type="number" readonly title="Fortitude save based on CON">
      </div>
      <div>
        <label>Willpower Save</label>
        <input id="willpower" type="number" readonly title="Willpower save based on WIS">
      </div>
      <div>
        <label>Luck Save (Level 4+)</label>
        <input id="luck" type="number" readonly title="Luck save based on CHA (Level 4+)">
      </div>
      <div>
        <label>Fate Points</label>
        <input id="fatePointsCurrent" type="number" readonly>
        <button class="dynamic-button" onclick="spendFatePoint()">Spend Fate Point</button>
        <button id="fatePointsRegenerate" class="dynamic-button hidden" onclick="regenerateFatePoints()">Regenerate</button>
        <button id="fatePointsRest" class="dynamic-button hidden" onclick="restCharacter()">Rest (8 Hours)</button>
      </div>
      <div>
        <label>Paradox Points</label>
        <input id="paradoxPoints" type="number" value="0" readonly>
        <button class="dynamic-button" onclick="addParadoxPoint()">Add Paradox</button>
      </div>
    </div>
    <h2>Resources</h2>
    <div id="resourcesContainer"></div>
    <h2>Inherent Abilities</h2>
    <div id="inherentAbilitiesContainer"></div>
    <h2>Skills</h2>
    <div id="skillPointsDisplay">Skill Points: 20/20</div>
    <div id="skillsContainer"></div>
    <button class="add-button" onclick="addSkillField()">Add Skill</button>
    <h2>Starting Feats</h2>
    <div id="startingFeatsContainer"></div>
    <button class="add-button" onclick="addStartingFeatField()">Add Starting Feat</button>
    <h2>Level-Up Feats</h2>
    <div id="levelUpFeatsContainer"></div>
    <button class="add-button" onclick="addLevelUpFeatField()">Add Level-Up Feat</button>
    <h2>Advantages</h2>
    <div id="advantageWarning" class="advantage-warning">Select at least one disadvantage before adding advantages.</div>
    <div id="advantagesContainer"></div>
    <button class="add-button" onclick="addAdvantageField()">Add Advantage</button>
    <h2>Disadvantages</h2>
    <div id="disadvantagesContainer"></div>
    <button class="add-button" onclick="addDisadvantageField()">Add Disadvantage</button>
    <h2>Powers/Effects</h2>
    <div id="powersContainer"></div>
    <button id="addPowerButton" class="add-button" onclick="addPowerField()">Add Power/Effect</button>
    <h2>Inventory</h2>
    <div class="grid">
      <div>
        <label>Credits</label>
        <input id="credits" type="number" value="0" min="0" placeholder="Credits" title="Currency for purchases">
      </div>
      <div>
        <label>Rift Shards</label>
        <input id="shards" type="number" value="0" min="0" placeholder="Rift Shards" title="Rare magical currency">
      </div>
    </div>
    <div id="inventoryContainer"></div>
    <button class="add-button" onclick="addInventoryField()">Add Item</button>
    <h2>Combat</h2>
    <div id="weaponsContainer"></div>
    <button class="add-button" onclick="addWeaponField()">Add Weapon</button>
    <div id="armorContainer"></div>
    <button class="add-button" onclick="addArmorField()">Add Armor</button>
    <h2>Progression</h2>
    <div class="grid">
      <div>
        <label>Current XP</label>
        <input id="currentXP" type="number" value="0" min="0" placeholder="Current XP" title="Experience points earned">
      </div>
      <div>
        <label>Next Level XP</label>
        <input id="nextLevelXP" type="number" readonly title="XP needed for next level">
      </div>
    </div>
    <h2>Lifestyle</h2>
    <div class="grid">
      <div>
        <label>Lifestyle</label>
        <select id="charLifestyle" title="Daily living standard">
          <option value="Squalid">Squalid (0 Credits/day)</option>
          <option value="Modest">Modest (1 Credit/day)</option>
          <option value="Comfortable">Comfortable (5 Credits/day)</option>
          <option value="Luxurious">Luxurious (20 Credits/day)</option>
        </select>
      </div>
      <div>
        <label>Cost Paid</label>
        <input id="lifestyleCost" type="number" value="0" min="0" placeholder="Daily Cost" title="Credits spent on lifestyle">
      </div>
    </div>
    <h2>Downtime Activities</h2>
    <div id="downtimeContainer"></div>
    <button class="add-button" onclick="addDowntimeField()">Add Downtime Activity</button>
    <h2>Notes</h2>
    <textarea id="charNotes" placeholder="e.g., Faction standings, backstory details" title="Additional character notes"></textarea>
    <div class="button-group">
      <button onclick="generateCharacterSheet()">Generate Character Sheet</button>
      <button onclick="saveCharacter()">Save Character</button>
      <button onclick="document.getElementById('loadCharacterInput').click()">Load Character</button>
      <input id="loadCharacterInput" type="file" accept=".json" onchange="loadCharacter(event)" style="display: none;">
      <button onclick="clearSheetFields()">Clear Sheet Fields</button>
    </div>
  </div>
</div>

  <div id="results" class="results hidden" role="region" aria-live="polite">
    <h2>Roll Results</h2>
    <p id="rollResult" aria-label="Roll result details"></p>
    <p id="criticalResult" class="critical" aria-label="Critical result"></p>
    <p id="sanityResult" class="sanity" aria-label="Sanity result"></p>
    <p id="paradoxResult" class="paradox" aria-label="Paradox result"></p>
    <p id="levelNote" class="level-note" aria-label="Level note"></p>
  </div>

  <div id="history" class="history">
    <h2>Roll History</h2>
    <ul id="historyList"></ul>
  </div>
</div>

  <div id="sheetModal" class="modal">
    <div class="modal-content">
      <span class="close-button" onclick="closeModal()">×</span>
      <h2>Character Sheet Preview</h2>
      <div id="sheetPreview" class="sheet-preview"></div>
      <div class="button-group">
        <button onclick="exportToPDF()">Export to PDF</button>
        <button onclick="copySheetText()">Copy as Text</button>
      </div>
      <textarea id="sheetText" class="copyable-text hidden"></textarea>
    </div>
  </div>

<script>
  let statPointsSpent = { STR: 0, DEX: 0, CON: 0, INT: 0, WIS: 0, CHA: 0 };
  let skillCriticalTracker = {};
  let hasParadoxSuccess = false;
  let extendedProgress = 0;
  let featCounter = 0;
  let startingFeatCounter = 0;
  let levelUpFeatCounter = 0;
  let advantageCounter = 0;
  let disadvantageCounter = 0;
  let skillCounter = 0;
  let powerCounter = 0;
  let inventoryCounter = 0;
  let weaponCounter = 0;
  let armorCounter = 0;
  let downtimeCounter = 0;
  let resourceCounter = 0;
  let rolledStats = [];
  let assignedStats = {};
  let availableStats = [];
  let fatePointsUsedInEncounter = 0;
  let totalResourcesUsedInSession = 0;

  // Stat point system variables
  let statPointsAvailable = 0;
  let statPointsAllocated = { STR: 0, DEX: 0, CON: 0, INT: 0, WIS: 0, CHA: 0 };

  // Calculate stat points for a given level
  function getStatPointsForLevel(level) {
    return Math.floor(level / 3) * 2;
  }

  // Update stat point UI and logic
  function updateStatPointUI() {
    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    const totalPoints = getStatPointsForLevel(lvl);
    const spent = Object.values(statPointsAllocated).reduce((a, b) => a + b, 0);
    statPointsAvailable = totalPoints - spent;
    if (document.getElementById('statPointsAvailable')) {
      document.getElementById('statPointsAvailable').textContent = statPointsAvailable;
    }
    if (document.getElementById('statPointAllocation')) {
      document.getElementById('statPointAllocation').classList.toggle('hidden', statPointsAvailable <= 0 && spent === 0);
    }
  }

  // Allocate or remove a stat point
  function allocateStatPoint(stat, delta) {
    if (delta > 0 && statPointsAvailable <= 0) return;
    if (delta < 0 && statPointsAllocated[stat] <= 0) return;
    const input = document.getElementById('attr' + stat);
    if (!input) return;
    const val = parseInt(input.value) || 10;
    if (delta > 0 && val >= 18) return;
    if (delta < 0 && val <= 8) return;
    statPointsAllocated[stat] += delta;
    input.value = val + delta;
    updateStatPointUI();
    updateSheetInputs({ preserveAttributes: true });
  }

  // Reset stat points when level changes
  function resetStatPointsOnLevelChange() {
    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    const totalPoints = getStatPointsForLevel(lvl);
    let spent = Object.values(statPointsAllocated).reduce((a, b) => a + b, 0);
    // If spent > total, remove excess from stats in order
    if (spent > totalPoints) {
      let excess = spent - totalPoints;
      for (const stat of ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA']) {
        while (statPointsAllocated[stat] > 0 && excess > 0) {
          statPointsAllocated[stat]--;
          const input = document.getElementById('attr' + stat);
          if (input) input.value = Math.max(8, (parseInt(input.value) || 10) - 1);
          excess--;
        }
      }
    }
    updateStatPointUI();
  }

  // Save/load stat points with character sheet
  function saveStatPointsToData(data) {
    data.statPointsAllocated = { ...statPointsAllocated };
  }
  function loadStatPointsFromData(data) {
    if (data.statPointsAllocated) {
      statPointsAllocated = { ...data.statPointsAllocated };
      for (const stat of ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA']) {
        const input = document.getElementById('attr' + stat);
        if (input) input.value = 10 + statPointsAllocated[stat];
      }
      updateStatPointUI();
    }
  }

  // Hook into level change and character load
  const origUpdateSheetInputs = updateSheetInputs;
  updateSheetInputs = function(options = {}) {
    origUpdateSheetInputs(options);
    resetStatPointsOnLevelChange();
  };
  const origPopulateCharacterSheet = populateCharacterSheet;
  populateCharacterSheet = function(data) {
    origPopulateCharacterSheet(data);
    loadStatPointsFromData(data);
  };
  const origCollectCharacterData = collectCharacterData;
  collectCharacterData = function() {
    const data = origCollectCharacterData();
    saveStatPointsToData(data);
    return data;
  };

  const skillsList = [
    { name: 'Acrobatics', attr: 'DEX', specs: ['Tumbling', 'Balance'], cost: 2 },
    { name: 'Animal Handling', attr: 'WIS', specs: ['Training', 'Calming', 'Falconry', 'Large Saurians'], cost: 2 },
    { name: 'Appraise', attr: 'INT', specs: ['Artifacts', 'Trade Goods', 'Jewelry', 'Antiquities'], cost: 2 },
    { name: 'Artistic Expression', attr: 'CHA', specs: ['Painting', 'Sculpture', 'Drawing', 'Mosaic'], cost: 2 },
    { name: 'Athletics', attr: 'STR', specs: ['Climbing', 'Jumping', 'Swimming', 'Running', 'Lifting'], cost: 2 },
    { name: 'Concentration', attr: 'WIS', specs: [], cost: 2 },
    { name: 'Crafting', attr: 'INT', specs: ['Blacksmithing', 'Mechanics', 'Alchemy', 'Calligraphy'], cost: 2 },
    { name: 'Cryptography', attr: 'INT', specs: ['Codebreaking', 'Encryption'], cost: 2 },
    { name: 'Deception', attr: 'CHA', specs: [], cost: 2 },
    { name: 'Diplomacy', attr: 'CHA', specs: ['Negotiation', 'Mediation'], cost: 2 },
    { name: 'Disguise', attr: 'CHA', specs: ['Costume Crafting', 'Behavioral Disguise'], cost: 2 },
    { name: 'Escape Artist', attr: 'DEX', specs: ['Bindings', 'Confined Spaces'], cost: 2 },
    { name: 'Forgery', attr: 'INT', specs: ['Documents', 'Items'], cost: 2 },
    { name: 'Gambling', attr: 'CHA', specs: ['Chance Games', 'Strategy Games'], cost: 2 },
    { name: 'Insight', attr: 'WIS', specs: ['Emotional Insight', 'Deceptive Insight'], cost: 2 },
    { name: 'Intimidate', attr: 'WIS/STR', specs: ['Physical', 'Mental'], cost: 2 },
    { name: 'Investigate', attr: 'WIS', specs: ['Tracking', 'Analysis'], cost: 2 },
    { name: 'Knowledge', attr: 'INT', specs: ['Arcana', 'History', 'Culture', 'Nature', 'Religion', 'Engineering'], cost: 1 },
    { name: 'Language', attr: 'INT', specs: ['Common', 'Dead Languages', 'Tech-Code', 'Xeno Languages'], cost: 2 },
    { name: 'Lockpicking', attr: 'DEX', specs: ['Mechanical Locks', 'Electronic Locks'], cost: 2 },
    { name: 'Melee Weapon', attr: 'STR', specs: ['Slashing', 'Piercing', 'Bludgeoning', 'Unarmed', 'Crushing'], cost: 2 },
    { name: 'Navigate', attr: 'INT', specs: ['Terrestrial', 'Celestial', 'Ocean', 'Subterranean'], cost: 2 },
    { name: 'Perform', attr: 'CHA', specs: ['Music', 'Oratory', 'Dance'], cost: 2 },
    { name: 'Pilot', attr: 'DEX', specs: ['Mechanical', 'Autonomous Systems'], cost: 2 },
    { name: 'Persuade', attr: 'CHA', specs: ['Charm', 'Inspiration'], cost: 2 },
    { name: 'Ranged Weapons', attr: 'DEX', specs: ['Projectile', 'Thrown'], cost: 2 },
    { name: 'Research', attr: 'INT', specs: ['Archival', 'Digital'], cost: 2 },
    { name: 'Riding', attr: 'DEX', specs: ['Terrestrial', 'Large Saurians', 'Aerial Mounts'], cost: 2 },
    { name: 'Self-Control', attr: 'WIS', specs: [], cost: 2 },
    { name: 'Sleight of Hand', attr: 'DEX', specs: ['Pickpocketing', 'Sleight Tricks'], cost: 2 },
    { name: 'Stealth', attr: 'DEX', specs: ['Hiding', 'Sneaking'], cost: 2 },
    { name: 'Streetwise', attr: 'WIS', specs: ['Scrounging', 'Urban Culture'], cost: 2 },
    { name: 'Survival', attr: 'WIS', specs: ['Foraging', 'Tracking'], cost: 2 },
    { name: 'Technical Expertise', attr: 'INT', specs: ['Electronics', 'Mechanics', 'Hacking'], cost: 2 },
    { name: 'Treat Injury', attr: 'INT', specs: ['First Aid', 'Surgery'], cost: 2 },
    { name: 'Ancient Siegecraft', attr: 'STR', specs: ['Operation', 'Maintenance'], cost: 2 },
    { name: 'Heraldry', attr: 'INT', specs: ['Identification', 'Design'], cost: 2 },
    { name: 'Chariot Racing', attr: 'DEX', specs: ['Racing', 'Combat'], cost: 2 },
    { name: 'Quantum Engineering', attr: 'INT', specs: ['Devices', 'Fields'], cost: 2 },
    { name: 'Neural Interface', attr: 'INT', specs: ['AI Interaction', 'Drone Control'], cost: 2 },
    { name: 'Holo-Manipulation', attr: 'DEX', specs: ['Illusions', 'Displays'], cost: 2 },
    { name: 'Astrometrics', attr: 'INT', specs: ['Navigation', 'Analysis'], cost: 2 }
  ];

  const startingFeatsList = [
    { value: 'Fatemarked Agility', text: 'Fatemarked Agility (+2 DEX checks)', level: 1 },
    { value: 'Dimensional Instinct', text: 'Dimensional Instinct (+3 WIS dimensional shifts, sense rift)', level: 1 },
    { value: 'Mystic Resonance', text: 'Mystic Resonance (+2 CHA magic checks)', level: 1 },
    { value: 'Circuit Intuition', text: 'Circuit Intuition (+2 INT tech, +2 Technical Expertise)', level: 1 },
    { value: 'Iron Psyche', text: 'Iron Psyche (+2 Sanity, +2 WIS vs. fear/mental)', level: 1 },
    { value: 'Scholar’s Insight', text: 'Scholar’s Insight (+3 Knowledge, recall fact once/session)', level: 1 },
    { value: 'Streetwise Contact', text: 'Streetwise Contact (+3 Investigate underworld, contact ally)', level: 1 },
    { value: 'Artisan’s Craft', text: 'Artisan’s Craft (+3 Crafting, half crafting time)', level: 1 },
    { value: 'Veteran’s Grit', text: 'Veteran’s Grit (+4 Intimidate, +2 CHA lead)', level: 1 },
    { value: 'Performer’s Flair', text: 'Performer’s Flair (+3 Perform, +2 Deception, Persuasion)', level: 1 }
  ];

  const levelUpFeatsList = [
    { value: 'Fated Duelist', text: 'Fated Duelist (DEX for dual light melee)', level: 3, prereq: 'DEX 13+' },
    { value: 'Twin-Strike Precision', text: 'Twin-Strike Precision (Off-hand attack)', level: 3, prereq: 'Fated Duelist, DEX 15+' },
    { value: 'Master of Blades', text: 'Master of Blades (Extra off-hand attack)', level: 6, prereq: 'Twin-Strike Precision, DEX 17+' },
    { value: 'Swift Strike', text: 'Swift Strike (DEX for light melee, +2 vs. flat-footed)', level: 3, prereq: 'DEX 13+' },
    { value: 'Elegant Edge', text: 'Elegant Edge (DEX damage, +2 Acrobatics)', level: 3, prereq: 'Swift Strike, DEX 15+' },
    { value: 'Fated Elegance', text: 'Fated Elegance (Double DEX damage)', level: 6, prereq: 'Elegant Edge, DEX 17+' },
    { value: 'Crushing Might', text: 'Crushing Might (-2 attack, +4 damage)', level: 3, prereq: 'STR 15+' },
    { value: 'Relentless Force', text: 'Relentless Force (Extra attack on drop)', level: 3, prereq: 'Crushing Might, STR 16+' },
    { value: 'Tide of Ruin', text: 'Tide of Ruin (+6 damage, 1d6 AoE)', level: 6, prereq: 'Relentless Force, STR 18+' },
    { value: 'Steady Aim', text: 'Steady Aim (Ignore -4 range, +1d6 precision)', level: 3, prereq: 'DEX 13+' },
    { value: 'Swift Barrage', text: 'Swift Barrage (-2 attack, extra ranged)', level: 3, prereq: 'Steady Aim, DEX 15+' },
    { value: 'Deadly Volley', text: 'Deadly Volley (-1 penalty, +2d6 precision)', level: 6, prereq: 'Swift Barrage, DEX 17+' },
    { value: 'Unyielding Guard', text: 'Unyielding Guard (+2 AC melee, no move)', level: 3, prereq: 'CON 13+' },
    { value: 'Bulwark Defense', text: 'Bulwark Defense (+2 AC ranged)', level: 3, prereq: 'STR 13+' },
    { value: 'Reflexive Strike', text: 'Reflexive Strike (Opportunity attack)', level: 3, prereq: 'DEX 14+' },
    { value: 'Fate’s Dodge', text: 'Fate’s Dodge (No damage, move 10 ft)', level: 3, prereq: 'DEX 15+' },
    { value: 'Light Melee Proficiency', text: 'Light Melee Proficiency (1d4)', level: 3, prereq: 'STR 12+ or DEX 12+' },
    { value: 'Medium Melee Proficiency', text: 'Medium Melee Proficiency (1d6)', level: 3, prereq: 'Light Melee Proficiency, STR 13+' },
    { value: 'Heavy Melee Proficiency', text: 'Heavy Melee Proficiency (1d8)', level: 3, prereq: 'Medium Melee Proficiency, STR 15+' },
    { value: 'Light Ranged Proficiency', text: 'Light Ranged Proficiency (1d6)', level: 3, prereq: 'DEX 12+' },
    { value: 'Medium Ranged Proficiency', text: 'Medium Ranged Proficiency (1d8)', level: 3, prereq: 'Light Ranged Proficiency, DEX 13+' },
    { value: 'Heavy Ranged Proficiency', text: 'Heavy Ranged Proficiency (1d10)', level: 3, prereq: 'Medium Ranged Proficiency, DEX 15+' },
    { value: 'Exotic Melee Proficiency', text: 'Exotic Melee Proficiency (1d12)', level: 3, prereq: 'STR 14+ or CHA 14+' },
    { value: 'Exotic Ranged Proficiency', text: 'Exotic Ranged Proficiency (1d12)', level: 3, prereq: 'DEX 14+ or INT 14+' },
    { value: 'Heavy Ordnance Proficiency', text: 'Heavy Ordnance Proficiency (2d12)', level: 3, prereq: 'INT 16+' }
  ];

  const advantagesList = [
    { name: 'Sniper', maxTier: 5, desc: 'Add Concentration rank to ranged attack/damage' },
    { name: 'Feint', maxTier: 5, desc: 'Deception adds tiers to attack/Dodge' },
    { name: 'Reckless Abandon', maxTier: 5, desc: 'Reduce AC by tiers, add to attack/damage' },
    { name: 'Animal Empathy', maxTier: 5, desc: 'Add tiers to Riding/Animal Handling' },
    { name: 'Size Up Opponent', maxTier: 1, desc: 'Insight vs. Deception to assess combat' },
    { name: 'Attractive', maxTier: 5, desc: 'Add tiers to CHA-based tests' },
    { name: 'Melee Expert', maxTier: 3, desc: 'Substitute tiers for Melee Weapon rank' },
    { name: 'Two for Flinching', maxTier: 1, desc: 'Intimidate forces opponent hesitation' },
    { name: 'Defensive Fighter', maxTier: 5, desc: 'Penalty to attack adds to Block/Defense' },
    { name: 'Diehard', maxTier: 1, desc: 'Auto-stabilize at 0' },
    { name: 'Recall', maxTier: 5, desc: 'Add tiers to INT recall tests' },
    { name: 'Evasion', maxTier: 5, desc: 'Add evasive to Dodge vs. area attacks' },
    { name: 'Enamor', maxTier: 4, desc: 'Social skills captures attention' },
    { name: 'Wrestling', maxTier: 2, desc: 'Grapple and deal damage' },
    { name: 'Fearless', maxTier: 1, desc: 'Immune to fear, +2 Self-Control' },
    { name: 'Tireless', maxTier: 5, desc: 'Add tiers to CON vs. exhaustion' },
    { name: 'Improved Critical', maxTier: 4, desc: 'Increase crit range by tiers' },
    { name: 'Improved Disarm', maxTier: 3, desc: 'No penalties, +2 disarm' },
    { name: 'Deft Grappler', maxTier: 1, desc: 'Grapple with one hand' },
    { name: 'Improved Initiative', maxTier: 5, desc: 'Add tiers to Initiative' },
    { name: 'Improved Defensive', maxTier: 5, desc: 'Penalty to escape grapples' },
    { name: 'MacGyver', maxTier: 1, desc: 'No penalty without tools' },
    { name: 'Inspire', maxTier: 5, desc: 'Fate inspired points adds tiers to ally tests' },
    { name: 'On Your Feet', maxTier: 1, desc: 'Stand as free action' },
    { name: 'Meat Shield', maxTier: 1, desc: 'Take attack for ally' },
    { name: 'Jack of All Trades', maxTier: 1, desc: 'Attempt skills Trained, -2 untrained', prereq: 'INT 13' },
    { name: 'Multilingual', maxTier: 5, desc: 'Additional language per tier' },
    { name: 'Rabbit’s Luck', maxTier: 5, desc: 'Extra Fate Chance per 5 tiers' },
    { name: 'Drive-By', maxTier: 1, desc: 'Pause movement for action' },
    { name: 'Brute Force', maxTier: 5, desc: 'Penalty to melee attack adds damage' },
    { name: 'Surgical Precision', maxTier: 4, desc: 'Ignore cover/concealment' },
    { name: 'Ground Fighting', maxTier: 1, desc: 'No penalties prone' },
    { name: 'Quick Draw', maxTier: 1, desc: 'Ready weapon as free action' },
    { name: 'Rapid Reload', maxTier: 1, desc: 'Reload as free action' },
    { name: 'Ranged Weapons Mastery', maxTier: 3, desc: 'Substitute tiers for Ranged Weapons rank' }
  ];

  const disadvantagesList = [
    { name: 'Nearsighted', title: 'Nearsightedness', maxTier: 5, desc: '-Tier to Perception/Ranged beyond 30 ft' },
    { name: 'Social Anxiety', maxTier: 5, desc: '-Tier to CHA in social settings' },
    { name: 'Bum Knee', maxTier: 5, desc: '-Tier to Acrobatics/Athletics running/jumping' },
    { name: 'Arachnophobia', maxTier: 5, desc: 'DC 15 WIS near spiders, -Tier on failure' },
    { name: 'Poor Judge of Character', maxTier: 1, desc: '-2 Insight outside combat' },
    { name: 'Chronic Stutter', maxTier: 5, desc: '-Tier to Persuasion/Perform speaking' },
    { name: 'Weak Grip', maxTier: 5, desc: '-Tier to Melee Weapon after crit fail' },
    { name: 'Low Pain Tolerance', maxTier: 1, desc: '-2 Concentration after damage' },
    { name: 'Chronic Back Pain', maxTier: 5, desc: '-Tier to Reflex saves' },
    { name: 'Slow Healing', maxTier: 1, desc: '-2 CON to recover Health' },
    { name: 'Migraines', maxTier: 5, desc: '-Tier to INT after Concentration fail' },
    { name: 'Asthma', maxTier: 5, desc: '-Tier to CON for prolonged activity' },
    { name: 'Allergic Reaction', maxTier: 4, desc: 'DC 15 CON vs. allergens, -Tier' },
    { name: 'Claustrophobia', maxTier: 2, desc: 'DC 15 WIS in confined spaces, -Tier' },
    { name: 'Impulsiveness', maxTier: 1, desc: '-2 WIS to plan/assess risks' },
    { name: 'Insomnia', maxTier: 5, desc: '-Tier to CON after long rest' },
    { name: 'Shaky Hands', maxTier: 4, desc: '-Tier to DEX fine motor skills' },
    { name: 'Old Shoulder Injury', maxTier: 3, desc: '-Tier to STR after grapple/disarm' },
    { name: 'Weak Ankles', maxTier: 1, desc: '-2 DEX to avoid falling' },
    { name: 'Poor Reaction Time', maxTier: 5, desc: '-Tier to Reflex outside combat' },
    { name: 'Acrophobia', maxTier: 5, desc: 'DC 15 WIS at heights, -Tier' },
    { name: 'Perfectionism', maxTier: 1, desc: '-2 INT when rushed' },
    { name: 'Self-Doubt', maxTier: 5, desc: '-Tier to CHA after skill fail' },
    { name: 'Overcautious Nature', maxTier: 1, desc: '-2 Initiative when surprised' },
    { name: 'Chronic Fatigue', maxTier: 1, desc: '-2 STR after moving 30+ ft' },
    { name: 'Lack of Focus', maxTier: 1, desc: '-2 Trained skills after Untrained' },
    { name: 'Dyslexia', maxTier: 5, desc: '-Tier to INT with written text' },
    { name: 'Superstition', maxTier: 5, desc: '-Tier to WIS without luck ritual' },
    { name: 'Poor Balance', maxTier: 1, desc: '-2 DEX on uneven terrain' },
    { name: 'Arthritis', maxTier: 5, desc: '-Tier to STR after prolonged combat' },
    { name: 'Hard of Hearing', maxTier: 4, desc: '-Tier to Perception sound' },
    { name: 'Poor Memory', maxTier: 1, desc: '-2 INT to recall details' },
    { name: 'Anxiety Under Pressure', maxTier: 1, desc: '-2 WIS under time pressure' },
    { name: 'Motion Sickness', maxTier: 1, desc: 'DC 15 CON in rapid motion, -2 DEX' },
    { name: 'Tinnitus', maxTier: 5, desc: '-Tier to Concentration in combat' },
    { name: 'Allergies', maxTier: 3, desc: 'DC 15 CON in allergens, -Tier' },
    { name: 'Agoraphobia', maxTier: 3, desc: 'DC 15 WIS in open areas, -Tier' },
    { name: 'Low Willpower', maxTier: 5, desc: '-Tier to Willpower vs. mental' },
    { name: 'Fear of Blood', maxTier: 3, desc: 'DC 15 WIS seeing blood, -Tier' }
  ];

  /**
   * Collects and returns the current character's data from the character sheet form.
   * Gathers skills, advantages, disadvantages, powers, level, class, and attributes.
   * @returns {Object|null} Character data object with skills, advantages, disadvantages, powers, level, class, and attributes, or null if character name is missing.
   */
  function getCharacterData() {
  try {
    const charName = document.getElementById('charName').value.trim();
    console.log('getCharacterData: charName=', charName); // Debug: Log character name
    if (!charName) {
      console.warn('No character name provided, returning null');
      return null;
    }

    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    const cls = document.getElementById('charClass').value || 'Fatemarked';
    // Validate class
    const validClasses = [
      'Fatemarked', 'Biomatrix Suit', 'Continuum Raider', 'Gunrunner', 'Faterunner',
      'Harlequin', 'Warrior', 'Mage', 'Shape', 'Masque', 'Adventurer'
    ];
    const validatedCls = validClasses.includes(cls) ? cls : 'Fatemarked';
    console.log(`getCharacterData: level=${lvl}, class=${validatedCls}`); // Debug: Log level and class

    // Collect attributes
    const attributes = {
      STR: parseInt(document.getElementById('attrSTR').value) || 10,
      DEX: parseInt(document.getElementById('attrDEX').value) || 10,
      CON: parseInt(document.getElementById('attrCON').value) || 10,
      INT: parseInt(document.getElementById('attrINT').value) || 10,
      WIS: parseInt(document.getElementById('attrWIS').value) || 10,
      CHA: parseInt(document.getElementById('attrCHA').value) || 10
    };
    // Add statPointsSpent to character data for saving/loading
    const statPoints = { ...statPointsSpent };

    const skills = [];
    const advantages = [];
    const disadvantages = [];
    const powers = [];

    // Collect skills
    const skillElements = document.querySelectorAll('[id^="skill"]:not([id*="Rank"]):not([id*="spec"])');
    console.log('getCharacterData: Found', skillElements.length, 'skill elements'); // Debug
    skillElements.forEach((el) => {
      const idMatch = el.id.match(/skill(\d+)/);
      if (idMatch && el.tagName === 'SELECT') {
        const i = idMatch[1];
        const skillElement = document.getElementById(`skill${i}`);
        const rankInput = document.getElementById(`skillRank${i}`);
        if (skillElement && skillElement.value) {
          const skillData = skillsList.find(s => s.name === skillElement.value);
          if (skillData) {
            const specs = skillData.specs.filter(spec => document.getElementById(`spec${i}_${spec}`)?.checked);
            skills.push({
              name: skillElement.value,
              rank: parseInt(rankInput?.value) || 0,
              specs: specs
            });
            console.log(`getCharacterData: Added skill ${skillElement.value} (Rank ${rankInput?.value}, Specs: ${specs.join(', ')})`); // Debug
          }
        }
      }
    });

    // Collect advantages (starting feats, level-up feats, and advantages)
    const startingFeatElements = document.querySelectorAll('[id^="startingFeat"]:not([id*="Desc"])');
    console.log('getCharacterData: Found', startingFeatElements.length, 'starting feat elements'); // Debug
    startingFeatElements.forEach((el) => {
      const idMatch = el.id.match(/startingFeat(\d+)/);
      if (idMatch && el.tagName === 'SELECT') {
        const i = idMatch[1];
        const featElement = document.getElementById(`startingFeat${i}`);
        if (featElement && featElement.value !== 'none') {
          advantages.push({
            name: featElement.value,
            tier: 1,
            desc: document.getElementById(`startingFeatDesc${i}`)?.value || ''
          });
          console.log(`getCharacterData: Added starting feat ${featElement.value}`); // Debug
        }
      }
    });

    const levelUpFeatElements = document.querySelectorAll('[id^="levelUpFeat"]:not([id*="Desc"])');
    console.log('getCharacterData: Found', levelUpFeatElements.length, 'level-up feat elements'); // Debug
    levelUpFeatElements.forEach((el) => {
      const idMatch = el.id.match(/levelUpFeat(\d+)/);
      if (idMatch && el.tagName === 'SELECT') {
        const i = idMatch[1];
        const featElement = document.getElementById(`levelUpFeat${i}`);
        if (featElement && featElement.value !== 'none') {
          advantages.push({
            name: featElement.value,
            tier: 1,
            desc: document.getElementById(`levelUpFeatDesc${i}`)?.value || ''
          });
          console.log(`getCharacterData: Added level-up feat ${featElement.value}`); // Debug
        }
      }
    });

    const advantageElements = document.querySelectorAll('[id^="advantage"]:not([id*="Tier"])');
    console.log('getCharacterData: Found', advantageElements.length, 'advantage elements'); // Debug
    advantageElements.forEach((el) => {
      const idMatch = el.id.match(/advantage(\d+)/);
      if (idMatch && el.tagName === 'SELECT') {
        const i = idMatch[1];
        const advElement = document.getElementById(`advantage${i}`);
        const tierInput = document.getElementById(`advantageTier${i}`);
        if (advElement && advElement.value !== 'none') {
          advantages.push({
            name: advElement.value,
            tier: parseInt(tierInput?.value) || 1
          });
          console.log(`getCharacterData: Added advantage ${advElement.value} (Tier ${tierInput?.value})`); // Debug
        }
      }
    });

    // Collect disadvantages
    const disadvantageElements = document.querySelectorAll('[id^="disadvantage"]:not([id*="Tier"])');
    console.log('getCharacterData: Found', disadvantageElements.length, 'disadvantage elements'); // Debug
    disadvantageElements.forEach((el) => {
      const idMatch = el.id.match(/disadvantage(\d+)/);
      if (idMatch && el.tagName === 'SELECT') {
        const i = idMatch[1];
        const disElement = document.getElementById(`disadvantage${i}`);
        const tierInput = document.getElementById(`disadvantageTier${i}`);
        if (disElement && disElement.value !== 'none') {
          disadvantages.push({
            name: disElement.value,
            tier: parseInt(tierInput?.value) || 1
          });
          console.log(`getCharacterData: Added disadvantage ${disElement.value} (Tier ${tierInput?.value})`); // Debug
        }
      }
    });

    // Collect powers
    if (lvl <= 3 && validatedCls === 'Fatemarked') {
      if (lvl >= 1) powers.push({ name: 'Fate’s Edge', level: 'PL1', cost: 0, dc: 15, risk: 'INT DC 15, -1 penalty' });
      if (lvl >= 2) powers.push({ name: 'Fate’s Influence', level: 'PL1', cost: 0, dc: 15, risk: 'INT DC 15, -1 or anomaly' });
      if (lvl >= 3) powers.push({ name: 'Fate’s Reach', level: 'PL1', cost: 0, dc: 15, risk: 'INT DC 15, -2 or rift' });
      console.log('getCharacterData: Added Fatemarked powers for Level', lvl); // Debug
    } else if (lvl > 3 && !['Faterunner', 'Harlequin'].includes(validatedCls)) {
      const powerElements = document.querySelectorAll('[id^="powerName"]');
      console.log('getCharacterData: Found', powerElements.length, 'power elements'); // Debug
      powerElements.forEach((el) => {
        const idMatch = el.id.match(/powerName(\d+)/);
        if (idMatch) {
          const i = idMatch[1];
          const nameInput = document.getElementById(`powerName${i}`);
          if (nameInput && nameInput.value) {
            powers.push({
              name: nameInput.value,
              level: document.getElementById(`powerLevel${i}`)?.value || 'PL1',
              cost: parseInt(document.getElementById(`powerCost${i}`)?.value) || 0,
              dc: parseInt(document.getElementById(`powerDC${i}`)?.value) || 10,
              risk: document.getElementById(`powerRisk${i}`)?.value || 'None'
            });
            console.log(`getCharacterData: Added power ${nameInput.value} (Level ${document.getElementById(`powerLevel${i}`)?.value})`); // Debug
          }
        }
      });
    }

    const charData = { skills, advantages, disadvantages, powers, level: lvl, class: validatedCls, attributes, statPoints };
    console.log('getCharacterData: Returning data:', JSON.stringify(charData, null, 2)); // Debug
    return charData;
  } catch (error) {
    console.error('Error getting character data:', error);
    alert('Failed to get character data. Check console for details.');
    return null;
  }
}

  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  function resetInputs() {
    try {
    const type = document.getElementById('rollType').value || 'skill';
    const modifierInput = document.getElementById('modifier');
    const skillRankInput = document.getElementById('skillRank');

    // Preserve modifier and skillRank for skill-based rolls
    const currentModifier = modifierInput ? parseInt(modifierInput.value) || 0 : 0;
    const currentSkillRank = skillRankInput ? parseInt(skillRankInput.value) || 0 : 0;

    document.getElementById('bab').value = 0;
    document.getElementById('dc').value = '';
    document.getElementById('ac').value = 15;
    document.getElementById('opponentRoll').value = 0;
    document.getElementById('cumulativeDC').value = '';
    document.getElementById('customParadoxDC').value = '';
    document.getElementById('classFeatTier').value = 1;
    document.getElementById('customFeat').value = '';
    document.getElementById('synergyBonus').checked = false;
    document.getElementById('envAdvantage').checked = false;
    document.getElementById('coverConcealment').value = 'none';
    document.getElementById('powerLevel').value = 'none';
    document.getElementById('paradoxDC').value = 'custom';
    document.getElementById('classFeat').value = 'none';
    document.getElementById('advantage').value = 'none';
    document.getElementById('featContainer').innerHTML = '';
    featCounter = 0;

    if (!['skill', 'extended', 'opposed', 'extendedOpposed'].includes(type)) {
      if (modifierInput) modifierInput.value = 0;
      if (skillRankInput) skillRankInput.value = 0;
      console.log('resetInputs: Reset modifier and skillRank to 0 for non-skill roll type', type);
    } else {
      if (modifierInput) modifierInput.value = currentModifier;
      if (skillRankInput) skillRankInput.value = currentSkillRank;
      console.log(`resetInputs: Preserved modifier=${currentModifier}, skillRank=${currentSkillRank} for ${type}`);
    }

    updateInputs();
  } catch (error) {
    console.error('Error resetting inputs:', error);
    alert('Failed to reset inputs. Please refresh the page.');
  }
}

  function updateFeats() {
    try {
        const lvl = parseInt(document.getElementById('characterLevel').value) || 1;
        const cls = document.getElementById('characterClass').value || 'Fatemarked';
        const classFeatSelect = document.getElementById('classFeat');
        const dynamicFeatSelects = document.querySelectorAll('.dynamic-feat');
        const selectedFeats = [
            classFeatSelect.value,
            ...Array.from(dynamicFeatSelects).map(s => s.value)
        ].filter(v => v && v !== 'none');

        const classFeats = {
            'Fatemarked': ['Fatemarked Agility', 'Dimensional Instinct', 'Mystic Resonance', 'Circuit Intuition', 'Iron Psyche', 'Scholar’s Insight', 'Streetwise Contact', 'Artisan’s Craft', 'Veteran’s Grit', 'Performer’s Flair'],
            'Biomatrix Suit': ['Circuit Intuition', 'Sniper', 'Surgical Precision', 'MacGyver'],
            'Continuum Raider': ['Fatemarked Agility', 'Dimensional Instinct', 'Improved Disarm', 'Survival'],
            'Gunrunner': ['Sniper', 'Steady Aim', 'Surgical Precision', 'Improved Critical'],
            'Faterunner': ['Mystic Resonance', 'Feint', 'Rabbit’s Luck', 'Evasion'],
            'Harlequin': ['Mystic Resonance', 'Feint', 'Rabbit’s Luck', 'Evasion'],
            'Warrior': ['Veteran’s Grit', 'Crushing Might', 'Improved Disarm', 'Improved Defensive'],
            'Mage': ['Mystic Resonance', 'Dimensional Instinct', 'Iron Psyche', 'Recall'],
            'Shape': ['Fatemarked Agility', 'Dimensional Instinct', 'Improved Defensive', 'Evasion'],
            'Masque': ['Mystic Resonance', 'Feint', 'Enamor', 'Evasion'],
            'Adventurer': ['Fatemarked Agility', 'Dimensional Instinct', 'Circuit Intuition', 'Iron Psyche', 'Scholar’s Insight', 'Jack of All Trades']
        };

        let availableFeats = [...startingFeatsList, ...levelUpFeatsList, ...advantagesList.map(a => ({ value: a.name, text: `${a.name} (${a.desc})` }))].filter(f => (!f.level || f.level <= lvl) && (!f.prereq || checkFeatPrereq(f.prereq, lvl)));
        availableFeats.unshift({ value: 'none', text: 'None' });
        availableFeats.push({ value: 'custom', text: 'Custom Feat' });
        if (cls === 'Adventurer' && lvl >= 4) availableFeats.push({ value: 'Versatile Feat', text: 'Versatile Feat (Extra Feat, Level 4+)' });

        const classAvailableFeats = availableFeats.filter(f => f.value === 'none' || classFeats[cls].includes(f.value) || f.value === 'custom' || (cls === 'Adventurer' && f.value === 'Versatile Feat'));

        classFeatSelect.innerHTML = '';
        classAvailableFeats.forEach(f => {
            if (!selectedFeats.includes(f.value) || f.value === 'none' || f.value === classFeatSelect.value) {
                const opt = document.createElement('option');
                opt.value = f.value;
                opt.text = f.text;
                classFeatSelect.appendChild(opt);
            }
        });

        dynamicFeatSelects.forEach(select => {
            const currentValue = select.value;
            select.innerHTML = '';
            availableFeats.forEach(f => {
                if (!selectedFeats.includes(f.value) || f.value === 'none' || f.value === currentValue) {
                    const opt = document.createElement('option');
                    opt.value = f.value;
                    opt.text = f.text;
                    select.appendChild(opt);
                }
            });
            select.value = availableFeats.some(f => f.value === currentValue) ? currentValue : 'none';
        });

        updateInputs();
    } catch (error) {
        console.error('Error updating feats:', error);
        alert('Failed to update feats. Please refresh the page.');
    }
}

  function checkFeatPrereq(prereq, lvl) {
    const attrs = {
      STR: parseInt(document.getElementById('attrSTR')?.value) || 10,
      DEX: parseInt(document.getElementById('attrDEX')?.value) || 10,
      CON: parseInt(document.getElementById('attrCON')?.value) || 10,
      INT: parseInt(document.getElementById('attrINT')?.value) || 10,
      WIS: parseInt(document.getElementById('attrWIS')?.value) || 10,
      CHA: parseInt(document.getElementById('attrCHA')?.value) || 10
    };
    const classFeatSelect = document.getElementById('classFeat');
    const dynamicFeatSelects = document.querySelectorAll('.dynamic-feat');
    const selectedFeats = [
      classFeatSelect.value,
      ...Array.from(dynamicFeatSelects).map(s => s.value)
    ].filter(v => v && v !== 'none');

    if (prereq.includes('DEX')) {
      const match = prereq.match(/DEX (\d+)\+/);
      if (match && attrs.DEX < parseInt(match[1])) return false;
    }
    if (prereq.includes('STR')) {
      const match = prereq.match(/STR (\d+)\+/);
      if (match && attrs.STR < parseInt(match[1])) return false;
    }
    if (prereq.includes('Fated Duelist') && !selectedFeats.includes('Fated Duelist')) return false;
    if (prereq.includes('Twin-Strike Precision') && !selectedFeats.includes('Twin-Strike Precision')) return false;
    if (prereq.includes('Swift Strike') && !selectedFeats.includes('Swift Strike')) return false;
    if (prereq.includes('Elegant Edge') && !selectedFeats.includes('Elegant Edge')) return false;
    if (prereq.includes('Crushing Might') && !selectedFeats.includes('Crushing Might')) return false;
    if (prereq.includes('Relentless Force') && !selectedFeats.includes('Relentless Force')) return false;
    if (prereq.includes('Steady Aim') && !selectedFeats.includes('Steady Aim')) return false;
    if (prereq.includes('Swift Barrage') && !selectedFeats.includes('Swift Barrage')) return false;
    if (prereq.includes('CON') && prereq.match(/CON (\d+)\+/) && attrs.CON < parseInt(prereq.match(/CON (\d+)\+/)[1])) return false;
    if (prereq.includes('Light Melee Proficiency') && !selectedFeats.includes('Light Melee Proficiency')) return false;
    if (prereq.includes('Medium Melee Proficiency') && !selectedFeats.includes('Medium Melee Proficiency')) return false;
    if (prereq.includes('Light Ranged Proficiency') && !selectedFeats.includes('Light Ranged Proficiency')) return false;
    if (prereq.includes('Medium Ranged Proficiency') && !selectedFeats.includes('Medium Ranged Proficiency')) return false;
    if (prereq.includes('CHA') && prereq.match(/CHA (\d+)\+/) && attrs.CHA < parseInt(prereq.match(/CHA (\d+)\+/)[1])) return false;
    if (prereq.includes('INT') && prereq.match(/INT (\d+)\+/) && attrs.INT < parseInt(prereq.match(/INT (\d+)\+/)[1])) return false;
    return true;
  }

  function addFeatField() {
    try {
      featCounter++;
      const container = document.getElementById('featContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <select class="dynamic-feat feat-select" title="Additional feat or advantage" onchange="debouncedUpdateFeatsSheet()">
          <option value="none">None</option>
        </select>
        <input type="number" class="dynamic-feat-tier" min="1" max="5" value="1" style="width: 100px;" placeholder="Tier" title="Feat or advantage tier">
        <button class="remove-button" onclick="removeFeatField(this)">Remove</button>
      `;
      container.appendChild(div);
      updateFeats();
    } catch (error) {
      console.error('Error adding feat field:', error);
      alert('Failed to add feat field.');
    }
  }

  function removeFeatField(button) {
    try {
      button.parentElement.remove();
      featCounter--;
      debouncedUpdateFeatsSheet();
    } catch (error) {
      console.error('Error removing feat field:', error);
      alert('Failed to remove feat field.');
    }
  }

  function updateFeatOptions() {
    try {
      const classFeatSelect = document.getElementById('classFeat');
      const dynamicFeatSelects = document.querySelectorAll('.dynamic-feat');
      const allSelects = [classFeatSelect, ...dynamicFeatSelects];
      const selectedFeats = allSelects.map(s => s.value).filter(v => v !== 'none');
      const tieredFeats = advantagesList.filter(a => a.maxTier > 1).map(a => a.name);

      allSelects.forEach(select => {
        const currentValue = select.value;
        Array.from(select.options).forEach(option => {
          option.disabled = option.value !== 'none' && selectedFeats.includes(option.value) && option.value !== currentValue;
        });
        if (select.id === 'classFeat') {
          document.getElementById('classFeatTierInput').classList.toggle('hidden', !tieredFeats.includes(currentValue));
        }
        const group = select.closest('.dynamic-group');
        if (group) {
          const tierInput = group.querySelector('.dynamic-feat-tier');
          tierInput.classList.toggle('hidden', !tieredFeats.includes(currentValue));
        }
      });
    } catch (error) {
      console.error('Error updating feat options:', error);
      alert('Failed to update feat options.');
    }
  }

  function updateParadoxDC() {
    try {
      const paradoxDC = document.getElementById('paradoxDC').value;
      document.getElementById('customParadoxDC').classList.toggle('hidden', paradoxDC !== 'custom');
    } catch (error) {
      console.error('Error updating paradox DC:', error);
      alert('Failed to update paradox DC.');
    }
  }

  function updateInputs() {
    try {
    const type = document.getElementById('rollType').value || 'skill';
    const charData = getCharacterData();
    const skillSelect = document.getElementById('skillName');
    const modifierInput = document.getElementById('modifier');
    const skillRankInput = document.getElementById('skillRank');
    const savingTypeSelect = document.getElementById('savingType');
    const babInput = document.getElementById('bab');
    const rollFormulaInput = document.getElementById('rollFormula');

    console.log('updateInputs: charData=', JSON.stringify(charData, null, 2)); // Debug

    // Update level and class
    const levelInput = document.getElementById('characterLevel');
    const classInput = document.getElementById('characterClass');
    const charLevelInput = document.getElementById('charLevel');
    const charClassInput = document.getElementById('charClass');
    let level = 1;
    let cls = 'Fatemarked';
    if (charData && charData.level && charData.class) {
      level = charData.level;
      cls = charData.class;
      if (levelInput) {
        const prevLevel = levelInput.value;
        levelInput.value = level;
        console.log(`updateInputs: Set characterLevel from ${prevLevel} to ${level}`);
        if (prevLevel !== level.toString()) {
          updateFeats();
          updateClassAbilities();
        }
      }
      if (classInput) {
        const validClasses = Array.from(classInput.options).map(opt => opt.value);
        const prevClass = classInput.value;
        classInput.value = validClasses.includes(cls) ? cls : 'Fatemarked';
        console.log(`updateInputs: Set characterClass from ${prevClass} to ${classInput.value}`);
        if (prevClass !== classInput.value) {
          updateFeats();
          updateClassAbilities();
        }
      }
    } else if (charLevelInput && charClassInput) {
      level = parseInt(charLevelInput.value) || 1;
      cls = charClassInput.value || 'Fatemarked';
      if (levelInput) {
        const prevLevel = levelInput.value;
        levelInput.value = level;
        console.log(`updateInputs: Fallback set characterLevel from ${prevLevel} to ${levelInput.value}`);
        if (prevLevel !== levelInput.value.toString()) {
          updateFeats();
          updateClassAbilities();
        }
      }
      if (classInput) {
        const validClasses = Array.from(classInput.options).map(opt => opt.value);
        const prevClass = classInput.value;
        classInput.value = validClasses.includes(cls) ? cls : 'Fatemarked';
        console.log(`updateInputs: Fallback set characterClass from ${prevClass} to ${classInput.value}`);
        if (prevClass !== classInput.value) {
          updateFeats();
          updateClassAbilities();
        }
      }
    } else {
      if (levelInput) {
        levelInput.value = '1';
        console.log('updateInputs: Set characterLevel to default 1');
      }
      if (classInput) {
        classInput.value = 'Fatemarked';
        console.log('updateInputs: Set characterClass to default Fatemarked');
      }
      updateFeats();
      updateClassAbilities();
    }

    // Define visibility mapping
    const mapping = {
      damageDiceInput: ['damage', 'nonLethal'],
      customDiceInput: ['custom'],
      skillRankInput: ['skill', 'extended'],
      babInput: ['attack', 'disarm', 'grapple', 'trip'],
      savingTypeInput: ['saving'],
      paradoxDCInput: ['paradox'],
      powerLevelInput: ['skill', 'extended', 'opposed', 'extendedOpposed'],
      dcInput: ['skill', 'sanity', 'saving', 'paradox', 'hazard', 'extended'],
      acInput: ['attack', 'disarm', 'trip'],
      opponentRollInput: ['opposed', 'extendedOpposed', 'grapple'],
      cumulativeDCInput: ['extended', 'extendedOpposed'],
      skillNameInput: ['skill', 'extended', 'opposed', 'extendedOpposed'],
      skillSpecInput: ['skill', 'extended', 'opposed', 'extendedOpposed'],
      advantageSelectInput: ['skill', 'attack', 'sanity', 'saving', 'paradox', 'hazard', 'extended', 'opposed', 'extendedOpposed', 'disarm', 'grapple', 'trip'],
      disadvantageSelectInput: ['skill', 'attack', 'sanity', 'saving', 'paradox', 'hazard', 'extended', 'opposed', 'extendedOpposed', 'disarm', 'grapple', 'trip'],
      powerSelectInput: ['paradox'],
      synergyBonusInput: ['skill', 'extended'],
      coverConcealmentInput: ['attack', 'disarm', 'grapple', 'trip'],
      classFeatTierInput: advantagesList.filter(a => a.name === (document.getElementById('classFeat')?.value || 'none') && a.maxTier > 1).length ? [type] : [],
      customFeatInput: (document.getElementById('classFeat')?.value || 'none') === 'custom' ? [type] : [],
      paradoxCheckInput: ['paradox'].filter(() => ['Faterunner', 'Harlequin'].includes(charData?.class || document.getElementById('characterClass')?.value || 'Fatemarked')),
      rollFormulaInput: ['skill', 'attack', 'sanity', 'saving', 'initiative', 'paradox', 'hazard', 'damage', 'nonLethal', 'extended', 'opposed', 'extendedOpposed', 'disarm', 'grapple', 'trip', 'custom']
    };

    // Toggle visibility
    for (let id in mapping) {
      const element = document.getElementById(id);
      if (element) {
        element.classList.toggle('hidden', !mapping[id].includes(type));
      } else {
        console.warn(`updateInputs: Element ${id} not found`);
      }
    }

    // Get fallback attributes
    const attrsFallback = {
      STR: parseInt(document.getElementById('attrSTR')?.value) || 10,
      DEX: parseInt(document.getElementById('attrDEX')?.value) || 10,
      CON: parseInt(document.getElementById('attrCON')?.value) || 10,
      INT: parseInt(document.getElementById('attrINT')?.value) || 10,
      WIS: parseInt(document.getElementById('attrWIS')?.value) || 10,
      CHA: parseInt(document.getElementById('attrCHA')?.value) || 10
    };
    const attrs = charData && charData.attributes ? charData.attributes : attrsFallback;

    const getModifierValue = (score) => {
      if (score <= 2) return -4;
      if (score <= 4) return -3;
      if (score <= 6) return -2;
      if (score <= 8) return -1;
      if (score <= 10) return 0;
      if (score <= 12) return 1;
      if (score <= 14) return 2;
      if (score <= 16) return 3;
      if (score <= 18) return 4;
      return 5;
    };

    // Initialize roll formula
    let rollFormula = '';
    let modifier = 0;

    // Update fields based on roll type
    if (['skill', 'extended', 'opposed', 'extendedOpposed'].includes(type)) {
      const selectedSkill = skillSelect?.value || 'none';
      if (selectedSkill !== 'none') {
        const skillData = skillsList.find(s => s.name === selectedSkill);
        const charSkill = charData?.skills?.find(s => s.name === selectedSkill);
        if (skillData && modifierInput) {
          const attr = skillData.attr.split('/')[0];
          modifier = getModifierValue(attrs[attr] || 10);
          modifierInput.value = modifier;
          console.log(`updateInputs: Set modifier to ${modifier} for ${selectedSkill} (${attr})`);
        }
        if (charSkill && skillRankInput) {
          skillRankInput.value = charSkill.rank || 0;
          console.log(`updateInputs: Set skillRank to ${charSkill.rank} for ${selectedSkill}`);
        } else if (skillRankInput) {
          skillRankInput.value = 0;
          console.log(`updateInputs: Set skillRank to 0 for ${selectedSkill} (no charSkill)`);
        }
        const specSelect = document.getElementById('skillSpec');
        const synergyBonus = document.getElementById('synergyBonus')?.checked ? 2 : 0;
        rollFormula = `d20 + ${modifier} (${attr}) + ${skillRankInput?.value || 0} (Rank)${specSelect?.value !== 'none' ? ' + 2 (Spec)' : ''}${synergyBonus ? ' + 2 (Synergy)' : ''}`;
      }
    } else if (['attack', 'disarm', 'trip'].includes(type)) {
      if (modifierInput) {
        modifier = getModifierValue(attrs.DEX || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for ${type} (DEX)`);
      }
      if (babInput) {
        babInput.value = getBAB(level, cls);
        console.log(`updateInputs: Set BAB to ${babInput.value} for ${type}`);
      }
      const coverConcealment = document.getElementById('coverConcealment')?.value || 'none';
      rollFormula = `d20 + ${babInput?.value || 0} (BAB) + ${modifier} (DEX)${coverConcealment === 'cover' ? ' - 4 (Cover)' : ''}`;
    } else if (type === 'grapple') {
      if (modifierInput) {
        modifier = getModifierValue(attrs.STR || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for grapple (STR)`);
      }
      if (babInput) {
        babInput.value = getBAB(level, cls);
        console.log(`updateInputs: Set BAB to ${babInput.value} for grapple`);
      }
      rollFormula = `d20 + ${babInput?.value || 0} (BAB) + ${modifier} (STR)`;
    } else if (type === 'sanity') {
      if (modifierInput) {
        modifier = getModifierValue(attrs.WIS || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for sanity (WIS)`);
      }
      rollFormula = `d20 + ${modifier} (WIS)`;
    } else if (type === 'saving') {
      if (savingTypeSelect && modifierInput) {
        const savingType = savingTypeSelect.value || 'reflex';
        const attrMap = {
          reflex: 'DEX',
          fortitude: 'CON',
          willpower: 'WIS',
          luck: 'CHA'
        };
        modifier = getModifierValue(attrs[attrMap[savingType]] || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for saving (${savingType})`);
        rollFormula = `d20 + ${modifier} (${attrMap[savingType]})`;
      }
    } else if (type === 'initiative') {
      if (modifierInput) {
        modifier = getModifierValue(attrs.DEX || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for initiative (DEX)`);
      }
      rollFormula = `d20 + ${modifier} (DEX)`;
    } else if (type === 'paradox') {
      if (modifierInput) {
        const attr = ['Faterunner', 'Harlequin'].includes(cls) ? 'CHA' : 'INT';
        modifier = getModifierValue(attrs[attr] || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for paradox (${attr})`);
        rollFormula = `d20 + ${modifier} (${attr})`;
      }
    } else if (type === 'hazard') {
      if (modifierInput) {
        modifier = getModifierValue(attrs.WIS || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for hazard (WIS)`);
      }
      rollFormula = `d20 + ${modifier} (WIS)`;
    } else if (['damage', 'nonLethal'].includes(type)) {
      if (modifierInput) {
        modifier = getModifierValue(attrs.STR || 10);
        modifierInput.value = modifier;
        console.log(`updateInputs: Set modifier to ${modifier} for ${type} (STR)`);
      }
      const damageDice = document.getElementById('damageDice')?.value || '1d4';
      rollFormula = `${damageDice} + ${modifier} (STR)${type === 'nonLethal' ? ' - 2 (Non-Lethal)' : ''}`;
    } else if (type === 'custom') {
      if (modifierInput) {
        modifierInput.value = 0;
        console.log('updateInputs: Set modifier to 0 for custom');
      }
      const customDice = document.getElementById('customDice')?.value || '1d6';
      rollFormula = `${customDice}`;
    }

    // Set roll formula
    if (rollFormulaInput) {
      rollFormulaInput.value = rollFormula;
      console.log(`updateInputs: Set rollFormula to ${rollFormula}`);
    }

    // Populate skillName
    if (skillSelect) {
      skillSelect.innerHTML = '<option value="none">Select Skill</option>';
      if (charData && Array.isArray(charData.skills) && charData.skills.length > 0) {
        charData.skills.forEach(skill => {
          skillSelect.innerHTML += `<option value="${skill.name}">${skill.name} (Rank ${skill.rank})</option>`;
        });
        console.log('updateInputs: Populated skillSelect with', charData.skills.length, 'skills');
      } else {
        skillsList.forEach(skill => {
          skillSelect.innerHTML += `<option value="${skill.name}">${skill.name} (${skill.attr})</option>`;
        });
        console.log('updateInputs: Populated skillSelect with default skillsList');
      }
    } else {
      console.warn('updateInputs: skillName element not found');
    }

    // Populate skillSpec
    updateSkillSpecOptions();

    // Populate advantageSelect
    const advantageSelect = document.getElementById('advantageSelect');
    const advantageTierInput = document.getElementById('advantageTier');
    if (advantageSelect) {
      advantageSelect.innerHTML = '<option value="none">None</option>';
      if (charData && Array.isArray(charData.advantages) && charData.advantages.length > 0) {
        charData.advantages.forEach(adv => {
          advantageSelect.innerHTML += `<option value="${adv.name}">${adv.name} (Tier ${adv.tier})</option>`;
        });
        console.log('updateInputs: Populated advantageSelect with', charData.advantages.length, 'advantages');
      } else {
        advantagesList.forEach(adv => {
          advantageSelect.innerHTML += `<option value="${adv.name}">${adv.name} (${adv.desc})</option>`;
        });
        console.log('updateInputs: Populated advantageSelect with default advantagesList');
      }
      if (advantageTierInput) {
        advantageTierInput.classList.toggle('hidden', !advantagesList.some(a => a.name === advantageSelect.value && a.maxTier > 1));
      }
    } else {
      console.warn('updateInputs: advantageSelect element not found');
    }

    // Populate disadvantageSelect
    const disadvantageSelect = document.getElementById('disadvantageSelect');
    const disadvantageTierInput = document.getElementById('disadvantageTier');
    if (disadvantageSelect) {
      disadvantageSelect.innerHTML = '<option value="none">None</option>';
      if (charData && Array.isArray(charData.disadvantages) && charData.disadvantages.length > 0) {
        charData.disadvantages.forEach(dis => {
          disadvantageSelect.innerHTML += `<option value="${dis.name}">${dis.name} (Tier ${dis.tier})</option>`;
        });
        console.log('updateInputs: Populated disadvantageSelect with', charData.disadvantages.length, 'disadvantages');
      } else {
        disadvantagesList.forEach(dis => {
          disadvantageSelect.innerHTML += `<option value="${dis.name}">${dis.name} (${dis.desc})</option>`;
        });
        console.log('updateInputs: Populated disadvantageSelect with default disadvantagesList');
      }
      if (disadvantageTierInput) {
        disadvantageTierInput.classList.toggle('hidden', !disadvantagesList.some(d => d.name === disadvantageSelect.value && d.maxTier > 1));
      }
    } else {
      console.warn('updateInputs: disadvantageSelect element not found');
    }

    // Populate powerSelect
    const powerSelect = document.getElementById('powerSelect');
    if (powerSelect) {
      powerSelect.innerHTML = '<option value="none">None</option>';
      if (charData && Array.isArray(charData.powers) && charData.powers.length > 0) {
        charData.powers.forEach(power => {
          powerSelect.innerHTML += `<option value="${power.name}" data-cost="${power.cost}" data-dc="${power.dc}" data-risk="${power.risk}">${power.name} (${power.level})</option>`;
        });
        console.log('updateInputs: Populated powerSelect with', charData.powers.length, 'powers');
      } else {
        const lvl = charData?.level || parseInt(document.getElementById('characterLevel')?.value) || 1;
        const genericPowers = [
          { name: 'Light Energy Bolt', level: 'PL1', cost: 1, dc: 15, risk: 'None', effect: '1d6 + CHA, Burn (1d6 fire, DC 15 DEX save)' },
          { name: 'Medium Plasma Shot', level: 'PL2', cost: 2, dc: 15, risk: 'None', effect: '1d8 + CHA, Daze (-2 attacks, DC 15 CON save)' },
          { name: 'Heavy Kinetic Blast', level: 'PL3', cost: 3, dc: 15, risk: 'DC 15 INT/WIS', effect: '1d10 + CHA, Blast (10-ft. radius, DC 15 DEX save)' },
          { name: 'Exotic Antimatter Ray', level: 'PL3', cost: 3, dc: 18, risk: 'DC 18 INT/WIS', effect: '1d12 + CHA, Disintegrate (1d12/round, DC 15 CON save)' }
        ].filter(power => {
          if (power.level === 'PL2') return lvl >= 4;
          if (power.level === 'PL3') return lvl >= 7;
          return true;
        });
        genericPowers.forEach(power => {
          powerSelect.innerHTML += `<option value="${power.name}" data-cost="${power.cost}" data-dc="${power.dc}" data-risk="${power.risk}">${power.name} (${power.level})</option>`;
        });
        console.log('updateInputs: Populated powerSelect with default genericPowers');
      }
    } else {
      console.warn('updateInputs: powerSelect element not found');
    }

    // Populate powerLevel
    const powerLevelSelect = document.getElementById('powerLevel');
    if (powerLevelSelect) {
      powerLevelSelect.innerHTML = '<option value="none">None</option>';
      const cls = charData?.class || document.getElementById('characterClass')?.value || 'Fatemarked';
      const lvl = charData?.level || parseInt(document.getElementById('characterLevel')?.value) || 1;
      if (cls === 'Fatemarked' && lvl <= 3) {
        powerLevelSelect.innerHTML += '<option value="Fate\'s Edge">Fate\'s Edge (Advantage on one roll)</option>';
        if (lvl >= 2) powerLevelSelect.innerHTML += '<option value="Fate\'s Influence">Fate\'s Influence (As above, plus enemy disadvantage)</option>';
        if (lvl >= 3) powerLevelSelect.innerHTML += '<option value="Fate\'s Reach">Fate\'s Reach (As above, any roll)</option>';
        console.log('updateInputs: Populated powerLevelSelect with Fatemarked abilities');
      } else if (['paradox', 'skill', 'extended', 'opposed', 'extendedOpposed'].includes(type)) {
        powerLevelSelect.innerHTML += `
          <option value="PL1">PL 1 / Tier 1</option>
          ${lvl >= 7 ? '<option value="PL2">PL 2 / Tier 2</option>' : ''}
          ${lvl >= 11 ? '<option value="PL3">PL 3 / Tier 3</option>' : ''}
        `;
        console.log('updateInputs: Populated powerLevelSelect with power levels for', type);
      }
    } else {
      console.warn('updateInputs: powerLevel element not found');
    }

    updateParadoxDC();
  } catch (error) {
    console.error('Error updating inputs:', error);
    alert('Failed to update inputs.');
  }
}

  function updateSkillSpecOptions() {
    try {
    const skillSelect = document.getElementById('skillName');
    const specSelect = document.getElementById('skillSpec');
    const modifierInput = document.getElementById('modifier');
    const skillRankInput = document.getElementById('skillRank');
    const selectedSkill = skillSelect ? skillSelect.value : 'none';
    const charData = getCharacterData();

    if (specSelect) {
      specSelect.innerHTML = '<option value="none">None</option>';
      if (selectedSkill !== 'none' && skillSelect) {
        let specsAdded = false;
        if (charData && charData.skills) {
          const charSkill = charData.skills.find(s => s.name === selectedSkill);
          if (charSkill && charSkill.specs && charSkill.specs.length) {
            charSkill.specs.forEach(spec => {
              specSelect.innerHTML += `<option value="${spec}">${spec}</option>`;
            });
            specsAdded = true;
            console.log(`updateSkillSpecOptions: Populated ${charSkill.specs.length} specs for ${selectedSkill} from charData`);
          }
          if (charSkill && skillRankInput) {
            skillRankInput.value = charSkill.rank || 0;
            console.log(`updateSkillSpecOptions: Set skillRank to ${charSkill.rank} for ${selectedSkill}`);
          }
        }
        if (!specsAdded) {
          const skillData = skillsList.find(s => s.name === selectedSkill);
          if (skillData && skillData.specs && skillData.specs.length) {
            skillData.specs.forEach(spec => {
              specSelect.innerHTML += `<option value="${spec}">${spec}</option>`;
            });
            console.log(`updateSkillSpecOptions: Populated ${skillData.specs.length} default specs for ${selectedSkill}`);
          }
        }
      }
    } else {
      console.warn('updateSkillSpecOptions: skillSpec element not found');
    }

    // Update modifier
    const attrsFallback = {
      STR: parseInt(document.getElementById('attrSTR')?.value) || 10,
      DEX: parseInt(document.getElementById('attrDEX')?.value) || 10,
      CON: parseInt(document.getElementById('attrCON')?.value) || 10,
      INT: parseInt(document.getElementById('attrINT')?.value) || 10,
      WIS: parseInt(document.getElementById('attrWIS')?.value) || 10,
      CHA: parseInt(document.getElementById('attrCHA')?.value) || 10
    };
    const attrs = charData && charData.attributes ? charData.attributes : attrsFallback;

    if (selectedSkill !== 'none' && modifierInput) {
      const skillData = skillsList.find(s => s.name === selectedSkill);
      if (skillData) {
        const attr = skillData.attr.split('/')[0];
        const getModifierValue = (score) => {
          if (score <= 2) return -4;
          if (score <= 4) return -3;
          if (score <= 6) return -2;
          if (score <= 8) return -1;
          if (score <= 10) return 0;
          if (score <= 12) return 1;
          if (score <= 14) return 2;
          if (score <= 16) return 3;
          if (score <= 18) return 4;
          return 5;
        };
        modifierInput.value = getModifierValue(attrs[attr] || 10);
        console.log(`updateSkillSpecOptions: Set modifier to ${modifierInput.value} for ${selectedSkill} (${attr})`);
      }
    } else if (modifierInput && skillRankInput) {
      skillRankInput.value = 0;
      modifierInput.value = 0;
      console.log('updateSkillSpecOptions: Set skillRank and modifier to 0 (no skill selected)');
    }
  } catch (error) {
    console.error('Error updating skill specialization options:', error);
    alert('Failed to update skill specialization options.');
  }
}

  function toggleGMReference() {
    try {
      const gmSection = document.querySelector('.gm-reference');
      gmSection.classList.toggle('collapsed');
      const toggleButton = gmSection.querySelector('.toggle-button');
      toggleButton.textContent = gmSection.classList.contains('collapsed') ? 'Show GM Reference' : 'Hide GM Reference';
    } catch (error) {
      console.error('Error toggling GM reference:', error);
      alert('Failed to toggle GM reference.');
    }
  }

  function toggleCharacterSheet() {
    try {
      const sheetSection = document.querySelector('.character-sheet');
      sheetSection.classList.toggle('collapsed');
      const toggleButton = sheetSection.querySelector('.toggle-button');
      toggleButton.textContent = sheetSection.classList.contains('collapsed') ? 'Show Character Sheet Generator' : 'Hide Character Sheet Generator';
    } catch (error) {
      console.error('Error toggling character sheet:', error);
      alert('Failed to toggle character sheet.');
    }
  }

  function getBAB(level, cls) {
    if (['Warrior', 'Gunrunner'].includes(cls)) return level;
    if (['Biomatrix Suit', 'Continuum Raider', 'Faterunner', 'Harlequin', 'Shape'].includes(cls)) return Math.floor(level * 0.75);
    return Math.floor(level * 0.5);
  }

  function addResourceField() {
    try {
      const cls = document.getElementById('charClass').value;
      const lvl = parseInt(document.getElementById('charLevel').value) || 1;
      if (['Faterunner', 'Harlequin', 'Fatemarked', 'Adventurer'].includes(cls)) return; // Change #2
      resourceCounter++;
      const maxResources = lvl >= 4 ? 10 + (lvl - 4) : 0; // Change #14
      const resources = {
        'Biomatrix Suit': { name: 'Energy Cells', max: maxResources, recharge: '1-hour rest' },
        'Continuum Raider': { name: 'Bio-Energy Pool', max: maxResources, recharge: '1-hour rest' },
        'Gunrunner': { name: 'Credit Pool', max: maxResources, recharge: 'DC 15 check' },
        'Warrior': { name: 'Chi Pool', max: maxResources, recharge: '1-hour meditation' },
        'Mage': { name: 'Vitality Pool', max: maxResources, recharge: '1-hour rest' },
        'Shape': { name: 'Pathos Pool', max: maxResources, recharge: '1-hour ritual' },
        'Masque': { name: 'Soulshard Pool', max: maxResources, recharge: '1-hour ritual' }
      };
      const resource = resources[cls] || { name: 'None', max: 0, recharge: 'None' };
      if (resource.name !== 'None') {
        const div = document.createElement('div');
        div.className = 'dynamic-group';
        div.innerHTML = `
          <input id="resourceName${resourceCounter}" type="text" value="${resource.name}" readonly>
          <input id="resourceCurrent${resourceCounter}" type="number" min="0" value="${resource.max}">
          <input id="resourceMax${resourceCounter}" type="number" min="0" value="${resource.max}" readonly>
          <input id="resourceRecharge${resourceCounter}" type="text" value="${resource.recharge}" readonly>
          <button class="dynamic-button" onclick="spendResource(${resourceCounter})">Spend</button>
          <button class="dynamic-button" onclick="incrementResource(${resourceCounter})">Increment</button>
        `;
        document.getElementById('resourcesContainer').appendChild(div);
      }
    } catch (error) {
      console.error('Error adding resource field:', error);
      alert('Failed to add resource field.');
    }
  }

  function spendResource(id) {
    try {
    const current = document.getElementById(`resourceCurrent${id}`);
    const cls = document.getElementById('charClass').value;
    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    if (parseInt(current.value) > 0) {
      current.value = parseInt(current.value) - 1;
      totalResourcesUsedInSession += 1;
      if (!['Faterunner', 'Harlequin', 'Adventurer', 'Fatemarked'].includes(cls)) {
        if (totalResourcesUsedInSession > lvl || (totalResourcesUsedInSession > lvl + 1 && (totalResourcesUsedInSession - lvl - 1) % 2 === 0)) {
          rollParadoxRiskForFatePoint(1);
        }
      }
    } else {
      alert('No resources available to spend!');
    }
  } catch (error) {
    console.error('Error spending resource:', error);
    alert('Failed to spend resource.');
  }
}

  function incrementResource(id) {
    try {
      const current = document.getElementById(`resourceCurrent${id}`);
      const max = document.getElementById(`resourceMax${id}`);
      if (parseInt(current.value) < parseInt(max.value)) {
        current.value = parseInt(current.value) + 1;
      } else {
        alert('Resource at maximum!');
      }
    } catch (error) {
      console.error('Error incrementing resource:', error);
      alert('Failed to increment resource.');
    }
  }

  function updateClassAbilities() {
    try {
        const cls = document.getElementById('characterClass').value || 'Fatemarked';
        const lvl = parseInt(document.getElementById('characterLevel').value) || 1;
        const container = document.getElementById('abilitiesContainer');
        container.innerHTML = '';
        const abilities = {
            'Faterunner': [{ name: 'Luck’s Edge', uses: 1, desc: 'Reroll failed check' }],
            'Harlequin': [{ name: 'Illusion Weave', uses: 1, desc: '+2 Deception' }],
            'Biomatrix Suit': [{ name: 'Tech Surge', uses: 1, desc: '+2 Technical Expertise' }],
            'Continuum Raider': [{ name: 'Chaos Shift', uses: 1, desc: '+2 Survival' }],
            'Gunrunner': [{ name: 'Deadshot', uses: 1, desc: '+2 Ranged Weapons' }],
            'Warrior': [{ name: 'Chi Strike', uses: 1, desc: '+2 Melee Weapon' }],
            'Mage': [{ name: 'Arcane Pulse', uses: 1, desc: '+2 Knowledge' }],
            'Shape': [{ name: 'Morphic Form', uses: 1, desc: '+2 Stealth' }],
            'Masque': [{ name: 'Soul Veil', uses: 1, desc: '+2 Disguise' }],
            'Adventurer': [{ name: 'Versatile Skill', uses: 1, desc: '+2 Any Skill' }],
            'Fatemarked': [{ name: 'Fate’s Touch', uses: 1, desc: '+2 Any Check' }]
        };
        (abilities[cls] || []).forEach((ability, i) => {
            const div = document.createElement('div');
            div.className = 'dynamic-group';
            div.innerHTML = `
                <label>${ability.name} (${ability.desc})</label>
                <button id="ability${i}" class="dynamic-button" onclick="useAbility('${ability.name}', ${i})" ${localStorage.getItem(`ability_${ability.name}`) ? 'disabled' : ''}>Use</button>
            `;
            container.appendChild(div);
        });
    } catch (error) {
        console.error('Error updating class abilities:', error);
        alert('Failed to update class abilities.');
    }
}

  function useAbility(name, id) {
    try {
      localStorage.setItem(`ability_${name}`, 'used');
      document.getElementById(`ability${id}`).disabled = true;
      alert(`${name} used!`);
    } catch (error) {
      console.error('Error using ability:', error);
      alert('Failed to use ability.');
    }
  }

  function spendFatePoint() {
    try {
    const current = parseInt(document.getElementById('fatePointsCurrent').value) || 0;
    const cls = document.getElementById('charClass').value;
    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    let promptText = cls === 'Faterunner' || cls === 'Harlequin' ?
      'Action: Reroll (1 Fate Point), Negate Damage (2 Fate Points), Alter Fixed Point (3 Fate Points), Create Effect (1–3 Fate Points)' :
      'Action: Reroll (1 Fate Point), Negate Damage (2 Fate Points), Alter Fixed Point (3 Fate Points)';
    const action = prompt(promptText);
    let cost = 1;
    let isEffect = false;
    if (action) {
      const lowerAction = action.toLowerCase();
      if (lowerAction.includes('negate damage')) cost = 2;
      else if (lowerAction.includes('alter fixed point')) cost = 3;
      else if (lowerAction.includes('create effect') && (cls === 'Faterunner' || cls === 'Harlequin')) {
        isEffect = true;
        const tier = prompt('Tier: 1 (1 Fate Point), 2 (2 Fate Points), 3 (3 Fate Points)');
        if (tier === '2') cost = 2;
        else if (tier === '3') cost = 3;
        else cost = 1;
      }
      if (current >= cost) {
        document.getElementById('fatePointsCurrent').value = current - cost;
        alert(`${cost} Fate Point(s) spent on ${action}!`);
        totalResourcesUsedInSession += cost;
        if (!(cls === 'Faterunner' || cls === 'Harlequin') || (isEffect && cost > 1)) {
          if (totalResourcesUsedInSession > lvl || (totalResourcesUsedInSession > lvl + 1 && (totalResourcesUsedInSession - lvl - 1) % 2 === 0)) {
            rollParadoxRiskForFatePoint(cost);
          }
        }
      } else {
        alert(`Need ${cost} Fate Point(s)!`);
      }
    }
  } catch (error) {
    console.error('Error spending Fate Point:', error);
    alert('Failed to spend Fate Point.');
  }
}

  function rollParadoxRiskForFatePoint(cost) {
    try {
        const lvl = parseInt(document.getElementById('charLevel').value) || 1;
        const cls = document.getElementById('charClass').value;
        let totalPointsUsed = fatePointsUsedInEncounter + cost;

        // Only check paradox if total points used exceeds level
        if (totalPointsUsed <= lvl) {
            fatePointsUsedInEncounter += cost;
            return;
        }

        // First paradox check at level + 1, then every 2 points thereafter
        if (totalPointsUsed === lvl + 1 || (totalPointsUsed > lvl + 1 && (totalPointsUsed - lvl - 1) % 2 === 0)) {
            const paradoxNatural = rollD20();
            const paradoxMod = parseInt(document.getElementById('modifier').value) || 0;
            const paradoxDC = 15 + (totalPointsUsed > lvl + 3 ? 2 : 0); // Increase DC after 3 excess points
            const paradoxTotal = paradoxNatural + paradoxMod;
            let paradoxResult = `Paradox Risk Check: Rolled ${paradoxNatural}${paradoxMod ? ` + Modifier ${paradoxMod}` : ''}=${paradoxTotal} vs DC${paradoxDC}. `;
            if (paradoxNatural === 1 || paradoxTotal < paradoxDC - 10) {
                paradoxResult += cls === 'Faterunner' || cls === 'Harlequin' ?
                    'Epic Failure: Minor Rift (AC 14, 20 Health)!' : 'Epic Failure: Dimensional Beast (AC 15, 30 Health)!';
                addParadoxPoint();
                const sanityLoss = rollD4();
                document.getElementById('sanity').value = parseInt(document.getElementById('sanity').value) - sanityLoss;
                document.getElementById('sanityResult').innerHTML = `Sanity Loss: -${sanityLoss} due to epic paradox!`;
            } else if (paradoxTotal < paradoxDC) {
                if (paradoxTotal < paradoxDC - 5) {
                    paradoxResult += cls === 'Faterunner' || cls === 'Harlequin' ?
                        'Major Failure: Faint Shimmer (No Portal)!' : 'Major Failure: Minor Rift (Portal with Whispers)!';
                    addParadoxPoint();
                } else {
                    paradoxResult += cls === 'Faterunner' || cls === 'Harlequin' ?
                        'Minor Failure: Minor Anomaly (-1 Penalty for 1 Encounter)!' : 'Minor Failure: Temporal Backlash (-2 Penalty for 1 Encounter)!';
                    addParadoxPoint();
                }
            } else {
                paradoxResult += 'Success: Stable Continuum!';
            }
            document.getElementById('paradoxResult').innerHTML = paradoxResult;
            document.getElementById('results').classList.remove('hidden');
        }
        fatePointsUsedInEncounter += cost;
    } catch (error) {
        console.error('Error checking paradox risk:', error);
        alert('Failed to check paradox risk.');
    }
}

  function rollD20() {
    return Math.floor(Math.random() * 20) + 1;
  }

  function rollD4() {
    return Math.floor(Math.random() * 4) + 1;
  }

  function addParadoxPoint() {
    try {
      const current = parseInt(document.getElementById('paradoxPoints').value) || 0;
      document.getElementById('paradoxPoints').value = current + 1;
      alert('Paradox point added!');
    } catch (error) {
      console.error('Error adding paradox point:', error);
      alert('Failed to add paradox point.');
    }
  }

  function regenerateFatePoints() {
    try {
      const lvl = parseInt(document.getElementById('charLevel').value) || 1;
      document.getElementById('fatePointsCurrent').value = lvl <= 3 ? 0 : lvl;
      alert('Fate Points regenerated!');
      fatePointsUsedInEncounter = 0;
    } catch (error) {
      console.error('Error regenerating Fate Points:', error);
      alert('Failed to regenerate Fate Points.');
    }
  }

  function restCharacter() {
    try {
      const lvl = parseInt(document.getElementById('charLevel').value) || 1;
      document.getElementById('fatePointsCurrent').value = lvl <= 3 ? 0 : lvl;
      alert('Character rested: Fate Points reset!');
      fatePointsUsedInEncounter = 0;
      Object.keys(localStorage).forEach(key => {
        if (key.startsWith('ability_')) localStorage.removeItem(key);
      });
      updateClassAbilities();
    } catch (error) {
      console.error('Error resting character:', error);
      alert('Failed to rest character.');
    }
  }

  function updateSheetInputs(options = {}) {
    try {
      if (window.isLoadingCharacter && !options.preserveAttributes) {
        console.log('Skipping updateSheetInputs during loading unless preserveAttributes is set');
        return;
      }
      const lvl = parseInt(document.getElementById('charLevel').value) || 1;
      const prevLvl = parseInt(document.getElementById('charLevel').dataset.prevLevel || '1');
      const cls = document.getElementById('charClass').value || 'Fatemarked';
      if (lvl > prevLvl && parseInt(document.getElementById('fatePointsCurrent').value) >= lvl) {
        if (powerCounter >= lvl) {
          alert('Power limit reached! Sacrifice a power to gain 1 Fate Point.');
          const sacrifice = confirm('Sacrifice a power to regain 1 Fate Point?');
          if (sacrifice) removePowerField();
        }
      }
      document.getElementById('charLevel').dataset.prevLevel = lvl;
      document.getElementById('charAlignment').value = lvl <= 3 ? 'None' : document.getElementById('charAlignment').value || 'Balance';
      document.getElementById('nextLevelXP').value = getNextLevelXP(lvl);

      // Update BAB and other derived stats
      const babInput = document.getElementById('bab');
      const charBABInput = document.getElementById('charBAB');
      const healthInput = document.getElementById('health');
      const sanityInput = document.getElementById('sanity');
      const defenseInput = document.getElementById('defense');
      const initiativeInput = document.getElementById('initiative');
      const reflexInput = document.getElementById('reflex');
      const fortitudeInput = document.getElementById('fortitude');
      const willpowerInput = document.getElementById('willpower');
      const luckInput = document.getElementById('luck');
      const fatePointsInput = document.getElementById('fatePointsCurrent');

      // Get attributes
      const attrs = {
        STR: parseInt(document.getElementById('attrSTR')?.value) || 10,
        DEX: parseInt(document.getElementById('attrDEX')?.value) || 10,
        CON: parseInt(document.getElementById('attrCON')?.value) || 10,
        INT: parseInt(document.getElementById('attrINT')?.value) || 10,
        WIS: parseInt(document.getElementById('attrWIS')?.value) || 10,
        CHA: parseInt(document.getElementById('attrCHA')?.value) || 10
      };
      const charData = getCharacterData();
      if (charData && charData.attributes) {
        Object.assign(attrs, charData.attributes);
      }

      const getModifierValue = (score) => {
        if (score <= 2) return -4;
        if (score <= 4) return -3;
        if (score <= 6) return -2;
        if (score <= 8) return -1;
        if (score <= 10) return 0;
        if (score <= 12) return 1;
        if (score <= 14) return 2;
        if (score <= 16) return 3;
        if (score <= 18) return 4;
        return 5;
      };

      // Populate BAB
      const babValue = getBAB(lvl, cls);
      if (babInput) {
        babInput.value = babValue;
        console.log(`updateSheetInputs: Set bab to ${babInput.value} for Level ${lvl}, Class ${cls}`);
      } else {
        console.warn('updateSheetInputs: bab element not found');
      }
      if (charBABInput) {
        charBABInput.value = babValue;
        console.log(`updateSheetInputs: Set charBAB to ${charBABInput.value} for Level ${lvl}, Class ${cls}`);
      } else {
        console.warn('updateSheetInputs: charBAB element not found');
      }

      // Populate other derived stats
      if (healthInput) {
        const conMod = getModifierValue(attrs.CON);
        healthInput.value = (cls === 'Warrior' ? 10 : 8) + conMod + (lvl - 1) * (cls === 'Warrior' ? 6 : 4);
        console.log(`updateSheetInputs: Set health to ${healthInput.value}`);
      }
      if (sanityInput) {
        sanityInput.value = attrs.WIS + getModifierValue(attrs.WIS);
        console.log(`updateSheetInputs: Set sanity to ${sanityInput.value}`);
      }
      if (defenseInput) {
        defenseInput.value = 10 + getModifierValue(attrs.DEX);
        console.log(`updateSheetInputs: Set defense to ${defenseInput.value}`);
      }
      if (initiativeInput) {
        initiativeInput.value = getModifierValue(attrs.DEX);
        console.log(`updateSheetInputs: Set initiative to ${initiativeInput.value}`);
      }
      if (reflexInput) {
        reflexInput.value = getModifierValue(attrs.DEX) + (cls === 'Faterunner' ? 2 : 0);
        console.log(`updateSheetInputs: Set reflex to ${reflexInput.value}`);
      }
      if (fortitudeInput) {
        fortitudeInput.value = getModifierValue(attrs.CON) + (cls === 'Warrior' ? 2 : 0);
        console.log(`updateSheetInputs: Set fortitude to ${fortitudeInput.value}`);
      }
      if (willpowerInput) {
        willpowerInput.value = getModifierValue(attrs.WIS) + (cls === 'Mage' ? 2 : 0);
        console.log(`updateSheetInputs: Set willpower to ${willpowerInput.value}`);
      }
      if (luckInput) {
        luckInput.value = lvl >= 4 ? getModifierValue(attrs.CHA) : 0;
        console.log(`updateSheetInputs: Set luck to ${luckInput.value}`);
      }
      if (fatePointsInput) {
        fatePointsInput.value = lvl <= 3 ? 0 : lvl;
        console.log(`updateSheetInputs: Set fatePointsCurrent to ${fatePointsInput.value}`);
      }

      // Update attributes only if not preserving or not imported
      const attrMethod = document.getElementById('attrMethod').value;
      if (!options.preserveAttributes && attrMethod !== 'imported') {
        updateAttributes();
        const pointsRemaining = document.getElementById('pointsRemaining');
        if (pointsRemaining && attrMethod === 'pointBuy') {
          updatePoints();
        }
      } else {
        console.log('Preserving attributes during updateSheetInputs');
      }

      updateDerivedStats();
      updateSkills();
      debouncedUpdateFeatsSheet();
      if (!options.skipPowers) {
        updatePowers();
      } else {
        console.log('Skipped updatePowers during initialization');
      }

      // Update class dropdown
      const classSelect = document.getElementById('charClass');
      const currentClass = classSelect.value || 'Fatemarked';
      const advancedClasses = [
        'Fatemarked', 'Biomatrix Suit', 'Continuum Raider', 'Gunrunner', 'Faterunner', 'Harlequin',
        'Warrior', 'Mage', 'Shape', 'Masque', 'Adventurer'
      ];
      if (!window.isLoadingCharacter) {
        classSelect.innerHTML = lvl <= 3 ? '<option value="Fatemarked">Fatemarked</option>' :
          advancedClasses.map(cls => `<option value="${cls}" ${cls === currentClass ? 'selected' : ''}>${cls}</option>`).join('');
        if (lvl <= 3 && currentClass !== 'Fatemarked') {
          classSelect.value = 'Fatemarked';
        } else if (lvl > 3 && !advancedClasses.includes(currentClass)) {
          classSelect.value = 'Continuum Raider';
          console.warn(`Invalid class ${currentClass} for Level ${lvl}, setting to Continuum Raider`);
        }
      }
      classSelect.disabled = false;

      // Update UI elements
      document.getElementById('fatePointsRegenerate').classList.toggle('hidden', !['Faterunner', 'Harlequin'].includes(cls));
      document.getElementById('fatePointsRest').classList.toggle('hidden', !['Faterunner', 'Harlequin'].includes(cls));
      document.getElementById('addPowerButton').classList.toggle('hidden', lvl <= 3 || ['Faterunner', 'Harlequin'].includes(cls));

      // Update inherent abilities
      const inherentAbilitiesContainer = document.getElementById('inherentAbilitiesContainer');
      inherentAbilitiesContainer.innerHTML = '';
      const inherentAbilities = {
        'Biomatrix Suit': '+2 to INT-based checks',
        'Continuum Raider': '+2 to Survival and Navigate checks',
        'Gunrunner': '+2 to Ranged Weapons checks',
        'Faterunner': 'Tier 1 effects have no paradox risk',
        'Harlequin': '+2 to Deception checks',
        'Warrior': '+2 to Melee Weapon checks',
        'Mage': '+2 to Knowledge and Perform checks',
        'Shape': '+2 to Stealth checks',
        'Masque': '+2 to Disguise checks',
        'Adventurer': '+1 skill point per level, reduced cost for cross-class feats',
        'Fatemarked': 'None'
      };
      if (inherentAbilities[cls] !== 'None') {
        const div = document.createElement('div');
        div.className = 'dynamic-group';
        div.innerHTML = `<p><strong>Inherent Ability:</strong> ${inherentAbilities[cls]}</p>`;
        inherentAbilitiesContainer.appendChild(div);
      }

      // Update powers section
      const powersContainer = document.getElementById('powersContainer');
      if (cls === 'Fatemarked' && lvl <= 3) {
        powersContainer.innerHTML = '';
        powerCounter = 0;
        const fatemarkedAbilities = [
          { level: 1, name: 'Fate’s Edge', category: 'Manipulation', effect: 'Advantage on one roll/encounter', dc: 15, risk: 'INT DC 15, -1 penalty' },
          { level: 2, name: 'Fate’s Influence', category: 'Manipulation', effect: 'As above, plus disadvantage on enemy roll', dc: 15, risk: 'INT DC 15, -1 or anomaly' },
          { level: 3, name: 'Fate’s Reach', category: 'Manipulation', effect: 'As above, plus any roll', dc: 15, risk: 'INT DC 15, -2 or rift' }
        ];
        fatemarkedAbilities.forEach(ability => {
          if (lvl >= ability.level) {
            powerCounter++;
            const div = document.createElement('div');
            div.className = 'dynamic-group';
            div.style.display = 'flex';
            div.innerHTML = `
              <input id="powerName${powerCounter}" type="text" value="${ability.name}" style="width: 150px;" title="Name of the power" readonly>
              <input id="powerCategory${powerCounter}" type="text" value="${ability.category}" style="width: 100px;" title="Power category" readonly>
              <input id="powerLevel${powerCounter}" type="text" value="PL1" style="width: 100px;" title="Power level or tier" readonly>
              <input id="powerCost${powerCounter}" type="number" value="0" style="width: 100px;" title="Fate Point cost" readonly>
              <input id="powerEffect${powerCounter}" type="text" value="${ability.effect}" style="width: 200px;" title="Power effect" readonly>
              <input id="powerDC${powerCounter}" type="number" value="${ability.dc}" style="width: 100px;" title="Difficulty Class" readonly>
              <input id="powerRisk${powerCounter}" type="text" value="${ability.risk}" style="width: 200px;" title="Paradox risk" readonly>
            `;
            powersContainer.appendChild(div);
          }
        });
      } else if (cls === 'Fatemarked' && lvl > 3) {
        powersContainer.innerHTML = '<p>Fatemarked abilities lost at Level 4+. Select an advanced class.</p>';
        powerCounter = 0;
      } else if (lvl > 3 && !['Faterunner', 'Harlequin'].includes(cls)) {
        powersContainer.innerHTML = powerCounter > 0 ? powersContainer.innerHTML : '<p>Add powers using the button above.</p>';
        if (!options.skipPowers) updatePowers();
      } else if (['Faterunner', 'Harlequin'].includes(cls)) {
        powersContainer.innerHTML = '<p>No powers for Faterunner/Harlequin.</p>';
        powerCounter = 0;
      }

      skillCriticalTracker = {};
      if (!['Faterunner', 'Harlequin', 'Fatemarked', 'Adventurer'].includes(cls)) {
        document.getElementById('resourcesContainer').innerHTML = '';
        resourceCounter = 0;
        addResourceField();
      } else {
        document.getElementById('resourcesContainer').innerHTML = '';
        resourceCounter = 0;
      }
    } catch (error) {
      console.error('Error updating sheet inputs:', error);
      alert('Failed to update sheet inputs.');
    }
  }

  function getNextLevelXP(level) {
    if (level < 3) return 100 * level;
    if (level < 6) return 150 * level;
    if (level < 11) return 75 * level;
    return 50 * level;
  }

  function updateAttributes() {
    try {
      const method = document.getElementById('attrMethod').value;
      document.getElementById('rerollButton').classList.toggle('hidden', method !== 'random');
      document.getElementById('randomRolls').classList.toggle('hidden', method !== 'random');
      document.getElementById('confirmAssignments').classList.toggle('hidden', method !== 'random');
      const attrs = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];

      if (method === 'imported') {
        console.log('Skipping attribute reset for imported method');
        attrs.forEach(attr => {
          const input = document.getElementById(`attr${attr}`);
          if (input) input.readOnly = true;
          const assignSelect = document.getElementById(`assign${attr}`);
          if (assignSelect) assignSelect.classList.add('hidden');
        });
        document.getElementById('pointsRemaining').value = 'N/A';
        return;
      }

      if (method === 'random') {
        attrs.forEach(attr => {
          const input = document.getElementById(`attr${attr}`);
          input.readOnly = true;
          const assignSelect = document.getElementById(`assign${attr}`);
          assignSelect.classList.remove('hidden');
        });
        if (rolledStats.length === 0) rerollAttributes();
        document.getElementById('rolledStats').value = rolledStats.join(', ');
        document.getElementById('pointsRemaining').value = 'N/A';
      } else {
        attrs.forEach(attr => {
          document.getElementById(`attr${attr}`).value = 10;
          document.getElementById(`attr${attr}`).readOnly = false;
          const assignSelect = document.getElementById(`assign${attr}`);
          assignSelect.classList.add('hidden');
          assignSelect.innerHTML = '<option value="">Select Stat</option>';
          assignSelect.value = '';
          delete assignedStats[attr];
        });
        rolledStats = [];
        availableStats = [];
        document.getElementById('rolledStats').value = '';
        updatePoints();
      }
      updateDerivedStats();
    } catch (e) {
      console.error('Error updating attributes:', e);
      alert(`Failed to update attributes: ${e.message}`);
    }
  }

  function roll4d6DropLowest() {
    const rolls = Array(4).fill().map(() => Math.floor(Math.random() * 6) + 1);
    const lowest = Math.min(...rolls);
    const total = rolls.reduce((sum, roll) => sum + roll, 0) - lowest;
    console.log(`roll4d6DropLowest: Rolls=${rolls}, Dropped=${lowest}, Total=${total}`);
    return total;
  }

  function rerollAttributes() {
    try {
      rolledStats = Array(6).fill().map(() => roll4d6DropLowest()).sort((a, b) => b - a);
      availableStats = [...rolledStats];
      document.getElementById('rolledStats').value = rolledStats.join(', ');
      assignedStats = {};
  
      const attrs = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
      attrs.forEach(attr => {
        document.getElementById(`attr${attr}`).value = '';
        const assignSelect = document.getElementById(`assign${attr}`);
        assignSelect.innerHTML = '<option value="">Select Stat</option>' +
          rolledStats.map(stat => `<option value="${stat}">${stat}</option>`).join('');
        assignSelect.value = '';
        assignSelect.disabled = false;
      });
      // Clear all previous assignments
      Object.keys(assignedStats).forEach(attr => {
        delete assignedStats[attr];
      });
    } catch (e) {
      console.error('Error rerolling attributes:', e);
      alert(`Failed to reroll attributes: ${e.message}`);
    }
  }

  function assignStat(attr) {
    try {
      const select = document.getElementById(`assign${attr}`);
      const value = select.value;
      const prevValue = assignedStats[attr];

      if (prevValue && value !== prevValue) {
        availableStats.push(parseInt(prevValue));
        availableStats.sort((a, b) => b - a);
      }

      if (value) {
        const numValue = parseInt(value);
        const index = availableStats.indexOf(numValue);
        if (index === -1) {
          select.value = '';
          alert(`Value ${numValue} is already assigned!`);
          return;
        }
        availableStats.splice(index, 1);
        assignedStats[attr] = numValue;
        document.getElementById(`attr${attr}`).value = value;
      } else {
        delete assignedStats[attr];
        document.getElementById(`attr${attr}`).value = '';
      }

      const attrs = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
      attrs.forEach(a => {
        const assignSelect = document.getElementById(`assign${a}`);
        const currentValue = assignedStats[a] ? assignedStats[a].toString() : '';
        assignSelect.innerHTML = '<option value="">Select Stat</option>' +
          availableStats.map(stat => `<option value="${stat}" ${stat == currentValue ? 'selected' : ''}>${stat}</option>`).join('');
        assignSelect.value = currentValue;
        assignSelect.disabled = !!assignedStats[a] && a !== attr;
      });

      updateDerivedStats();
    } catch (e) {
      console.error('Error assigning stat:', e);
      alert(`Failed to assign stat: ${e.message}`);
    }
  }

  function assignStats() {
    try {
      const attrs = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
      let allAssigned = true;

      if (!rolledStats || !Array.isArray(rolledStats) || rolledStats.length !== 6) {
        throw new Error('rolledStats is invalid or empty');
      }

      const statFrequency = new Map();
      rolledStats.forEach(stat => {
        statFrequency.set(stat, (statFrequency.get(stat) || 0) + 1);
      });

      const assignedCounts = new Map();
      attrs.forEach(attr => {
        const input = document.getElementById(`attr${attr}`);
        if (!input) throw new Error(`Input attr${attr} not found`);
        const value = assignedStats[attr];
        if (value !== undefined) {
          const numValue = parseInt(value);
          if (!statFrequency.has(numValue)) throw new Error(`Invalid stat value ${numValue} assigned to ${attr}`);
          assignedCounts.set(numValue, (assignedCounts.get(numValue) || 0) + 1);
          if (assignedCounts.get(numValue) > statFrequency.get(numValue)) {
            alert(`Stat ${numValue} is assigned more times (${assignedCounts.get(numValue)}) than available (${statFrequency.get(numValue)})!`);
            const select = document.getElementById(`assign${attr}`);
            if (select) select.value = '';
            delete assignedStats[attr];
            input.value = '';
            allAssigned = false;
          } else {
            input.value = value.toString();
          }
        } else {
          allAssigned = false;
        }
      });

      if (allAssigned) {
        updateDerivedStats();
        attrs.forEach(attr => {
          const select = document.getElementById(`assign${attr}`);
          if (select) select.disabled = true;
        });
      } else {
        alert('Please assign a value to all attributes.');
      }
    } catch (e) {
      console.error('Error in assignStats:', e);
      alert(`Failed to assign stats: ${e.message}`);
    }
  }

  // Point-buy system: Each attribute score from 8 to 18 has a point cost.
  // Scores below 10 have negative costs, meaning you gain points back for lowering a stat below 10.
  // The player has 15 points to spend; exceeding this total is not allowed.
  // Example: 10 = 0, 12 = 2, 8 = -2 (so lowering a stat to 8 gives you 2 extra points to spend elsewhere).
  function updatePoints() {
    try {
      if (document.getElementById('attrMethod').value !== 'pointBuy') return;
      const pointCosts = { 8: -2, 9: -1, 10: 0, 11: 1, 12: 2, 13: 3, 14: 4, 15: 6, 16: 8, 17: 11, 18: 14 };
      const attrs = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
      let totalCost = 0;
      attrs.forEach(attr => {
        const score = parseInt(document.getElementById(`attr${attr}`).value) || 10;
        if (score >= 8 && score <= 18) totalCost += pointCosts[score];
        if (score < 8) document.getElementById(`attr${attr}`).value = 8;
        if (score > 18) document.getElementById(`attr${attr}`).value = 18;
      });
      const remaining = 15 - totalCost;
      document.getElementById('pointsRemaining').value = remaining;
      if (remaining < 0) alert('Points exceeded! Adjust attributes.');
      updateDerivedStats();
      updateSkills();
    } catch (e) {
      console.error('Error updating points:', e);
      alert('Failed to update points.');
    }
  }

  function updateDerivedStats() {
    try {
      const lvl = parseInt(document.getElementById('charLevel').value) || 1;
      const cls = document.getElementById('charClass').value || 'Fatemarked';
      const str = parseInt(document.getElementById('attrSTR').value) || 10;
      const dex = parseInt(document.getElementById('attrDEX').value) || 10;
      const con = parseInt(document.getElementById('attrCON').value) || 10;
      const wis = parseInt(document.getElementById('attrWIS').value) || 10;
      const cha = parseInt(document.getElementById('attrCHA').value) || 10;
      const conMod = getModifier(con);
      const dexMod = getModifier(dex);
      const wisMod = getModifier(wis);
      const chaMod = getModifier(cha);
      let acBonus = 0;
      for (let i = 1; i <= armorCounter; i++) {
        const armorAC = document.getElementById(`armorAC${i}`);
        if (armorAC) acBonus += parseInt(armorAC.value) || 0;
      }

      document.getElementById('health').value = lvl === 1 ? 10 + conMod : 10 + conMod + 5 * (lvl - 1);
      document.getElementById('sanity').value = lvl === 1 ? 10 + wisMod : 10 + wisMod + 2 * (lvl - 1);
      document.getElementById('defense').value = 10 + dexMod + acBonus;
      document.getElementById('initiative').value = dexMod;
      document.getElementById('bab').value = getBAB(lvl, cls);
      document.getElementById('reflex').value = 1 + dexMod;
      document.getElementById('fortitude').value = 1 + conMod;
      document.getElementById('willpower').value = 1 + wisMod;
      document.getElementById('luck').value = lvl >= 4 ? chaMod + 2 : 0;
    } catch (e) {
      console.error('Error updating derived stats:', e);
      alert('Failed to update derived stats.');
    }
  }

  function getModifier(score) {
    if (score <= 2) return -4;
    if (score <= 4) return -3;
    if (score <= 6) return -2;
    if (score <= 8) return -1;
    if (score <= 10) return 0;
    if (score <= 12) return 1;
    if (score <= 14) return 2;
    if (score <= 16) return 3;
    if (score <= 18) return 4;
    return 5;
  }

  function updateSkills() {
    try {
    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    const int = parseInt(document.getElementById('attrINT').value) || 10;
    const cls = document.getElementById('charClass').value || 'Fatemarked';
    const background = document.getElementById('charBackground').value.toLowerCase();
    const intMod = getModifier(int);
    const maxRank = lvl <= 1 ? 4 : 3 + lvl;
    const baseSkillPoints = cls === 'Adventurer' ? (5 + intMod + 1) : (5 + intMod);
    const skillPoints = lvl === 1 ? baseSkillPoints * 4 : baseSkillPoints * 4 + (2 + intMod + (cls === 'Adventurer' ? 1 : 0)) * (lvl - 1);
    let usedPoints = 0;
    const selectedSkills = new Set();

    const alignedSkills = {
      'Fatemarked': ['Insight', 'Knowledge'],
      'Biomatrix Suit': ['Technical Expertise', 'Crafting'],
      'Continuum Raider': ['Survival', 'Navigate'],
      'Gunrunner': ['Ranged Weapons'],
      'Faterunner': ['Deception', 'Persuade'],
      'Harlequin': ['Deception', 'Perform'],
      'Warrior': ['Melee Weapon', 'Intimidate'],
      'Mage': ['Knowledge', 'Perform'],
      'Shape': ['Stealth', 'Escape Artist'],
      'Masque': ['Disguise', 'Deception'],
      'Adventurer': ['Knowledge', 'Survival']
    };

    for (let i = 1; i <= skillCounter; i++) {
      const skillFieldSelect = document.getElementById(`skill${i}`);
      const rankInput = document.getElementById(`skillRank${i}`);
      if (skillFieldSelect && skillFieldSelect.value) {
        if (selectedSkills.has(skillFieldSelect.value)) {
          skillFieldSelect.value = '';
          continue;
        }
        selectedSkills.add(skillFieldSelect.value);
        let rank = parseInt(rankInput.value) || 0;
        if (rank > maxRank) {
          rankInput.value = maxRank;
          rank = maxRank;
        }
        usedPoints += rank;
        const skillData = skillsList.find(s => s.name === skillFieldSelect.value);
        if (skillData && skillData.specs.length) {
          const checkedSpecs = skillData.specs.filter(spec => document.getElementById(`spec${i}_${spec}`)?.checked);
          const specCost = (skillData.name === 'Knowledge' && checkedSpecs.includes('Arcana') && 
                           (alignedSkills[cls].includes('Knowledge') || background.includes('arcane'))) ? 1 : 2;
          usedPoints += checkedSpecs.length * specCost;
        }
      }
    }

    const remainingPoints = skillPoints - usedPoints;
    document.getElementById('skillPointsDisplay').innerHTML = `Skill Points: ${remainingPoints}/${skillPoints}`;
    if (remainingPoints < 0) {
      alert(`Skill points exceeded! Available: ${skillPoints}, Used: ${usedPoints}. Reduce ranks or specializations.`);
    }
  } catch (e) {
    console.error('Error updating skills:', e);
    alert('Failed to update skills.');
  }
}

  function addSkillField() {
    try {
      skillCounter++;
      const container = document.getElementById('skillsContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <select id="skill${skillCounter}" title="Select skill" onchange="updateSkillSpecs(${skillCounter})">
          <option value="">Select Skill</option>
          ${skillsList.map(s => `<option value="${s.name}">${s.name} (${s.attr})</option>`).join('')}
        </select>
        <input id="skillRank${skillCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="Rank" title="Skill rank" onchange="updateSkills()">
        <div id="skillSpecs${skillCounter}" style="display: inline;"></div>
        <button class="remove-button" onclick="removeSkillField(this)">Remove</button>
      `;
      container.appendChild(div);
      updateSkills();
    } catch (e) {
      console.error('Error adding skill field:', e);
      alert('Failed to add skill field.');
    }
  }

  function updateSkillSpecs(id) {
    try {
      const skill = document.getElementById(`skill${id}`).value;
      const specsDiv = document.getElementById(`skillSpecs${id}`);
      const skillData = skillsList.find(s => s.name === skill);
      if (skillData && skillData.specs.length) {
        specsDiv.innerHTML = skillData.specs.map(spec => `
          <label><input type="checkbox" id="spec${id}_${spec}" value="${spec}" title="${spec} specialization" onchange="handleSingleSpecSelect(${id}, '${spec}')">${spec}</label>
        `).join('');
      } else {
        specsDiv.innerHTML = '';
      }
      updateSkills();
    } catch (e) {
      console.error('Error updating skill specs:', e);
      alert('Failed to update skill specs.');
    }
  }

  function handleSingleSpecSelect(id, selectedSpec) {
    // Only allow one specialization per skill
    const skill = document.getElementById(`skill${id}`).value;
    const skillData = skillsList.find(s => s.name === skill);
    if (!skillData) return;
    skillData.specs.forEach(spec => {
      const checkbox = document.getElementById(`spec${id}_${spec}`);
      if (checkbox && spec !== selectedSpec) {
        checkbox.checked = false;
      }
    });
    updateSkills();
  }

  function removeSkillField(button) {
    try {
      button.parentElement.remove();
      skillCounter--;
      updateSkills();
    } catch (e) {
      console.error('Error removing skill field:', e);
      alert('Failed to remove skill field.');
    }
  }

  const debouncedUpdateFeatsSheet = debounce(updateFeatsSheet, 300);

  function updateFeatsSheet() {
    try {
      const lvl = parseInt(document.getElementById('charLevel').value) || 1;
      const cls = document.getElementById('charClass').value || 'Fatemarked';
      const int = parseInt(document.getElementById('attrINT').value) || 10;
      const maxFeats = cls === 'Adventurer' ? Math.floor(lvl / 2) + 2 : Math.floor(lvl / 2) + 1;
      let usedFeats = 0;
      const selectedFeats = [];
      const selectedAdvantages = [];

      let hasDisadvantages = false;
      for (let i = 1; i <= disadvantageCounter; i++) {
        const disSelect = document.getElementById(`disadvantage${i}`);
        if (disSelect && disSelect.value !== 'none') {
          hasDisadvantages = true;
          break;
        }
      }
      document.getElementById('advantageWarning').style.display = hasDisadvantages ? 'none' : 'block';

      for (let i = 1; i <= startingFeatCounter; i++) {
        const featSelect = document.getElementById(`startingFeat${i}`);
        if (featSelect && featSelect.value !== 'none') {
          if (selectedFeats.includes(featSelect.value) || selectedAdvantages.includes(featSelect.value)) {
            featSelect.value = 'none';
            alert(`Feat ${featSelect.value} already selected!`);
            continue;
          }
          selectedFeats.push(featSelect.value);
          usedFeats++;
          const descInput = document.getElementById(`startingFeatDesc${i}`);
          descInput.classList.toggle('hidden', featSelect.value !== 'custom');
          if (featSelect.value === 'Jack of All Trades' && int < 13) {
            featSelect.value = 'none';
            alert('Jack of All Trades requires INT 13+');
          }
        }
      }

      for (let i = 1; i <= levelUpFeatCounter; i++) {
        const featSelect = document.getElementById(`levelUpFeat${i}`);
        if (featSelect && featSelect.value !== 'none') {
          if (selectedFeats.includes(featSelect.value) || selectedAdvantages.includes(featSelect.value)) {
            featSelect.value = 'none';
            alert(`Feat ${featSelect.value} already selected!`);
            continue;
          }
          const featCost = (cls === 'Adventurer' && featSelect.value !== 'custom' && 
                           !startingFeatsList.some(f => f.value === featSelect.value) && 
                           !levelUpFeatsList.some(f => f.value === featSelect.value && f.prereq)) ? 0.5 : 1;
          selectedFeats.push(featSelect.value);
          usedFeats += featCost;
          const descInput = document.getElementById(`levelUpFeatDesc${i}`);
          descInput.classList.toggle('hidden', featSelect.value !== 'custom');
          const featData = levelUpFeatsList.find(f => f.value === featSelect.value);
          if (featData && featData.level > lvl) {
            featSelect.value = 'none';
            alert(`${featSelect.value} requires level ${featData.level}+`);
          }
        }
      }

      for (let i = 1; i <= advantageCounter; i++) {
        const advSelect = document.getElementById(`advantage${i}`);
        if (advSelect && advSelect.value !== 'none') {
          if (!hasDisadvantages) {
            advSelect.value = 'none';
            alert('Select at least one disadvantage before adding advantages.');
            continue;
          }
          if (selectedFeats.includes(advSelect.value) || selectedAdvantages.includes(advSelect.value)) {
            advSelect.value = 'none';
            alert(`Advantage ${advSelect.value} already selected!`);
            continue;
          }
          selectedAdvantages.push(advSelect.value);
          const tierInput = document.getElementById(`advantageTier${i}`);
          const advantage = advantagesList.find(a => a.name === advSelect.value);
          const tier = parseInt(tierInput.value) || 1;
          if (tier > advantage.maxTier) {
            tierInput.value = advantage.maxTier;
            alert(`Max tier for ${advSelect.value} is ${advantage.maxTier}`);
          }
          tierInput.classList.toggle('hidden', advantage.maxTier === 1);
          if (advSelect.value === 'Jack of All Trades' && int < 13) {
            advSelect.value = 'none';
            alert('Jack of All Trades requires INT 13+');
          }
        }
      }

      if (usedFeats > maxFeats) {
        alert(`Too many feats! Max: ${maxFeats}`);
      }

      updateDisadvantages();
    } catch (e) {
      console.error('Error updating feats:', e);
      alert('Failed to update feats.');
    }
  }

  function addStartingFeatField() {
    try {
      startingFeatCounter++;
      const container = document.getElementById('startingFeatsContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <select id="startingFeat${startingFeatCounter}" title="Starting feat" onchange="debouncedUpdateFeatsSheet()">
          <option value="none">None</option>
          ${startingFeatsList.map(f => `<option value="${f.value}">${f.text}</option>`).join('')}
          <option value="custom">Custom Feat</option>
        </select>
        <input id="startingFeatDesc${startingFeatCounter}" type="text" placeholder="Custom description" style="width: 200px;" title="Custom feat description" class="hidden">
        <button class="remove-button" onclick="removeStartingFeatField(this)">Remove</button>
      `;
      container.appendChild(div);
      debouncedUpdateFeatsSheet();
    } catch (e) {
      console.error('Error adding starting feat field:', e);
      alert('Failed to add starting feat field.');
    }
  }

  function removeStartingFeatField(button) {
    try {
      button.parentElement.remove();
      startingFeatCounter--;
      debouncedUpdateFeatsSheet();
    } catch (e) {
      console.error('Error removing starting feat field:', e);
      alert('Failed to remove starting feat field.');
    }
  }

  function addLevelUpFeatField() {
    try {
      levelUpFeatCounter++;
      const container = document.getElementById('levelUpFeatsContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <select id="levelUpFeat${levelUpFeatCounter}" title="Level-up feat" onchange="debouncedUpdateFeatsSheet()">
          <option value="none">None</option>
          ${levelUpFeatsList.map(f => `<option value="${f.value}">${f.text}</option>`).join('')}
          <option value="custom">Custom Feat</option>
        </select>
        <input id="levelUpFeatDesc${levelUpFeatCounter}" type="text" placeholder="Custom description" style="width: 200px;" title="Custom feat description" class="hidden">
        <button class="remove-button" onclick="removeLevelUpFeatField(this)">Remove</button>
      `;
      container.appendChild(div);
      debouncedUpdateFeatsSheet();
    } catch (e) {
      console.error('Error adding level-up feat field:', e);
      alert('Failed to add level-up feat field.');
    }
  }

  function removeLevelUpFeatField(button) {
    try {
      button.parentElement.remove();
      levelUpFeatCounter--;
      debouncedUpdateFeatsSheet();
    } catch (e) {
      console.error('Error removing level-up feat field:', e);
      alert('Failed to remove level-up feat field.');
    }
  }

  function addAdvantageField() {
    try {
      if (!window.isLoadingCharacter) {
        let hasDisadvantages = false;
        for (let i = 1; i <= disadvantageCounter; i++) {
          const disSelect = document.getElementById(`disadvantage${i}`);
          if (disSelect && disSelect.value !== 'none') {
            hasDisadvantages = true;
            break;
          }
        }
        if (!hasDisadvantages) {
          document.getElementById('advantageWarning').style.display = 'block';
          alert('Select at least one disadvantage before adding advantages.');
          return;
        }
      }

      advantageCounter++;
      const container = document.getElementById('advantagesContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <select id="advantage${advantageCounter}" title="Advantage" onchange="debouncedUpdateFeatsSheet()">
          <option value="none">None</option>
          ${advantagesList.map(a => `<option value="${a.name}">${a.name} (${a.desc})</option>`).join('')}
        </select>
        <input id="advantageTier${advantageCounter}" type="number" min="1" max="5" value="1" style="width: 100px;" placeholder="Tier" title="Advantage tier">
        <button class="remove-button" onclick="removeAdvantageField(this)">Remove</button>
      `;
      container.appendChild(div);
      debouncedUpdateFeatsSheet();
    } catch (e) {
      console.error('Error adding advantage field:', e);
      alert('Failed to add advantage field.');
    }
  }

  function removeAdvantageField(button) {
    try {
      button.parentElement.remove();
      advantageCounter--;
      debouncedUpdateFeatsSheet();
    } catch (e) {
      console.error('Error removing advantage field:', e);
      alert('Failed to remove advantage field.');
    }
  }

  function updateDisadvantages() {
    try {
      const selectedDisadvantages = [];
      let totalDisadvantageTiers = 0;
      for (let i = 1; i <= disadvantageCounter; i++) {
        const disSelect = document.getElementById(`disadvantage${i}`);
        if (disSelect && disSelect.value !== 'none') {
          if (selectedDisadvantages.includes(disSelect.value)) {
            disSelect.value = 'none';
            alert(`Disadvantage ${disSelect.value} already selected!`);
            continue;
          }
          selectedDisadvantages.push(disSelect.value);
          const tierInput = document.getElementById(`disadvantageTier${i}`);
          const disadvantage = disadvantagesList.find(d => d.name === disSelect.value);
          const tier = parseInt(tierInput.value) || 1;
          if (tier > disadvantage.maxTier) {
            tierInput.value = disadvantage.maxTier;
            alert(`Max tier for ${disSelect.value} is ${disadvantage.maxTier}`);
          }
          totalDisadvantageTiers += tier;
          tierInput.classList.toggle('hidden', disadvantage.maxTier === 1);
        }
      }
      let totalAdvantageTiers = 0;
      for (let i = 1; i <= advantageCounter; i++) {
        const advSelect = document.getElementById(`advantage${i}`);
        if (advSelect && advSelect.value !== 'none') {
          const advantage = advantagesList.find(a => a.name === advSelect.value);
          const tier = parseInt(document.getElementById(`advantageTier${i}`).value) || 1;
          totalAdvantageTiers += tier;
        }
      }
      if (totalAdvantageTiers > totalDisadvantageTiers) {
        alert(`Advantages (${totalAdvantageTiers} tiers) exceed disadvantages (${totalDisadvantageTiers} tiers)! Add more disadvantages.`);
      }
    } catch (e) {
      console.error('Error updating disadvantages:', e);
      alert('Failed to update disadvantages.');
    }
  }

  function addDisadvantageField() {
    try {
      disadvantageCounter++;
      const container = document.getElementById('disadvantagesContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <select id="disadvantage${disadvantageCounter}" title="Disadvantage" onchange="updateDisadvantages()">
          <option value="none">None</option>
          ${disadvantagesList.map(d => `<option value="${d.name}">${d.name} (${d.desc})</option>`).join('')}
        </select>
        <input id="disadvantageTier${disadvantageCounter}" type="number" min="1" max="5" value="1" style="width: 100px;" placeholder="Tier" title="Disadvantage tier">
        <button class="remove-button" onclick="removeDisadvantageField(this)">Remove</button>
      `;
      container.appendChild(div);
      updateDisadvantages();
    } catch (e) {
      console.error('Error adding disadvantage field:', e);
      alert('Failed to add disadvantage field.');
    }
  }

  function removeDisadvantageField(button) {
    try {
      button.parentElement.remove();
      disadvantageCounter--;
      updateDisadvantages();
      debouncedUpdateFeatsSheet();
    } catch (e) {
      console.error('Error removing disadvantage field:', e);
      alert('Failed to remove disadvantage field.');
    }
  }

  function addPowerField() {
    try {
    const cls = document.getElementById('charClass').value;
    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    const alignment = document.getElementById('charAlignment').value;
    if (lvl <= 3 || ['Faterunner', 'Harlequin'].includes(cls)) {
      return;
    }
    if (lvl > 3 && alignment === 'None') {
      alert('Please select an alignment to add powers.');
      return;
    }
    const container = document.getElementById('powersContainer');
    powerCounter++;
    const div = document.createElement('div');
    div.className = 'dynamic-group';
    div.style.display = 'flex';
    div.dataset.id = powerCounter; // Add data-id
    div.innerHTML = `
      <select id="powerCategory${powerCounter}" title="Power category" onchange="updatePowerCost(${powerCounter})">
        <option value="none">Select Category</option>
        <option value="Alteration">Alteration</option>
        <option value="Protection">Protection</option>
        <option value="Manipulation">Manipulation</option>
        <option value="Creation">Creation</option>
      </select>
      <input id="powerName${powerCounter}" type="text" placeholder="Power Name" style="width: 150px;" title="Name of the power">
      <select id="powerLevel${powerCounter}" title="Power level or tier" onchange="updatePowerCost(${powerCounter})">
        <option value="none">Select Tier</option>
        <option value="PL1">PL 1 / Tier 1</option>
        ${lvl >= 7 ? '<option value="PL2">PL 2 / Tier 2</option>' : ''}
        ${lvl >= 11 ? '<option value="PL3">PL 3 / Tier 3</option>' : ''}
      </select>
      <input id="powerCost${powerCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="Fate Point Cost" title="Fate Point cost" readonly>
      <input id="powerEffect${powerCounter}" type="text" placeholder="Effect (e.g., 1d6 Psychic)" style="width: 200px;" title="Power effect, including damage if applicable">
      <input id="powerDC${powerCounter}" type="number" min="10" value="10" style="width: 100px;" placeholder="DC" title="Difficulty Class, including range modifier">
      <input id="powerRisk${powerCounter}" type="text" placeholder="Paradox Risk (e.g., DC 18)" style="width: 200px;" title="Paradox risk, if applicable">
      <button class="remove-button" onclick="removePowerField(this)">Remove</button>
    `;
    container.appendChild(div);
    updatePowers();
  } catch (e) {
    console.error('Error adding power field:', e);
    alert('Failed to add power field.');
  }
}

  function updatePowerCost(id) {
    try {
    const powerLevel = document.getElementById(`powerLevel${id}`).value;
    const powerCategory = document.getElementById(`powerCategory${id}`).value;
    const cls = document.getElementById('charClass').value;
    const lvl = parseInt(document.getElementById('charLevel').value) || 1;
    const currentFatePoints = parseInt(document.getElementById('fatePointsCurrent').value) || 0;
    const prevCostInput = document.getElementById(`powerCost${id}`);
    const prevCost = prevCostInput.dataset.prevCost ? parseInt(prevCostInput.dataset.prevCost) : 0;
    let baseCost = 0;

    if (powerLevel !== 'none') {
      const tierNum = parseInt(powerLevel.replace('PL', '')) || 1;
      if (tierNum === 1 && lvl < 4) {
        alert(`Power Level 1 requires Level 4+!`);
        document.getElementById(`powerLevel${id}`).value = 'none';
        document.getElementById(`powerCost${id}`).value = 0;
        document.getElementById(`powerCost${id}`).dataset.prevCost = 0;
        return;
      }
      if (tierNum === 2 && lvl < 7) {
        alert(`Power Level 2 requires Level 7+!`);
        document.getElementById(`powerLevel${id}`).value = 'none';
        document.getElementById(`powerCost${id}`).value = 0;
        document.getElementById(`powerCost${id}`).dataset.prevCost = 0;
        return;
      }
      if (tierNum === 3 && lvl < 11) {
        alert(`Power Level 3 requires Level 11+!`);
        document.getElementById(`powerLevel${id}`).value = 'none';
        document.getElementById(`powerCost${id}`).value = 0;
        document.getElementById(`powerCost${id}`).dataset.prevCost = 0;
        return;
      }
      baseCost = tierNum;
    }

    if (prevCost > 0) {
      document.getElementById('fatePointsCurrent').value = currentFatePoints + prevCost;
      console.log(`Refunded ${prevCost} Fate Points for power ${id}`);
    }

    if (powerLevel !== 'none' && powerCategory !== 'none') {
      if (currentFatePoints < baseCost) {
        alert(`Not enough Fate Points! Need ${baseCost}, have ${currentFatePoints}.`);
        document.getElementById(`powerLevel${id}`).value = 'none';
        document.getElementById(`powerCost${id}`).value = 0;
        document.getElementById(`powerCost${id}`).dataset.prevCost = 0;
        return;
      }

      let damage = '';
      if (['Alteration', 'Creation'].includes(powerCategory)) {
        const attr = getClassAttribute(cls);
        if (powerLevel === 'PL1') {
          damage = powerCategory === 'Alteration' ? `1d6 + ${attr}` : `1d4 + ${attr}`;
        } else if (powerLevel === 'PL2') {
          damage = powerCategory === 'Alteration' ? `1d8 + ${attr}` : `1d6 + ${attr}`;
        } else if (powerLevel === 'PL3') {
          damage = powerCategory === 'Alteration' ? `1d10 + ${attr}` : `1d8 + ${attr}`;
        }
        document.getElementById(`powerEffect${id}`).value = damage;
      }

      document.getElementById(`powerRisk${id}`).value = powerLevel === 'PL1' ? 'None' : 
        powerLevel === 'PL2' ? 'DC 18' : lvl >= 11 ? 'DC 25' : 'DC 22';

      document.getElementById('fatePointsCurrent').value = currentFatePoints - baseCost;
      document.getElementById(`powerCost${id}`).value = baseCost;
      document.getElementById(`powerCost${id}`).dataset.prevCost = baseCost;
      console.log(`Deducted ${baseCost} Fate Points for power ${id}`);
    } else {
      document.getElementById(`powerCost${id}`).value = 0;
      document.getElementById(`powerCost${id}`).dataset.prevCost = 0;
    }
  } catch (e) {
    console.error('Error updating power cost:', e);
    alert('Failed to update power cost.');
  }
}

  function getClassResource(cls) {
    const resources = {
      'Biomatrix Suit': 'Energy Cells',
      'Continuum Raider': 'Bio-Energy Pool',
      'Gunrunner': 'Credit Pool',
      'Warrior': 'Chi Pool',
      'Mage': 'Vitality Pool',
      'Shape': 'Pathos Pool',
      'Masque': 'Soulshard Pool',
      'Faterunner': 'Fate Points',
      'Harlequin': 'Fate Points',
      'Adventurer': 'None',
      'Fatemarked': 'None'
    };
    return resources[cls] || 'Fate Points';
  }

  function getClassAttribute(cls) {
    const attributes = {
      'Biomatrix Suit': 'INT',
      'Continuum Raider': 'CON',
      'Gunrunner': 'DEX',
      'Warrior': 'STR',
      'Mage': 'INT',
      'Shape': 'CON',
      'Masque': 'CHA',
      'Faterunner': 'CHA',
      'Harlequin': 'CHA',
      'Adventurer': 'CHA',
      'Fatemarked': 'CHA'
    };
    return attributes[cls] || 'CHA';
  }

  function updateSynergyCost(id) {
    try {
      const charAlignment = document.getElementById('charAlignment').value;
      const powerAlignment = document.getElementById(`powerAlignment${id}`)?.value || 'None';
      const powerLevel = document.getElementById(`powerLevel${id}`).value;
      const cls = document.getElementById('charClass').value;
      const currentFatePoints = parseInt(document.getElementById('fatePointsCurrent').value) || 0;
      const resourceCurrent = parseInt(document.getElementById(`resourceCurrent${id}`)?.value) || 0;
      const prevCost = parseInt(document.getElementById(`powerCost${id}`).dataset.prevCost || '0');
      const resourceType = document.getElementById(`powerCost${id}`).dataset.resourceType || getClassResource(cls);
      const synergyCost = charAlignment === powerAlignment || charAlignment === 'None' ? 0 : 1;
      const synergyInput = document.getElementById(`powerSynergy${id}`);
      if (synergyInput) synergyInput.value = synergyCost;

      if (powerLevel !== 'none') {
        const baseCost = powerLevel === 'PL1' ? 1 : powerLevel === 'PL2' ? 2 : 3;
        const totalCost = baseCost + synergyCost;
        const resourceAvailable = resourceType === 'Fate Points' ? currentFatePoints : resourceCurrent;

        if (prevCost > 0) {
          if (resourceType === 'Fate Points') {
            document.getElementById('fatePointsCurrent').value = currentFatePoints + prevCost;
          } else {
            document.getElementById(`resourceCurrent${id}`).value = resourceCurrent + prevCost;
          }
          console.log(`Refunded ${prevCost} ${resourceType} for synergy update on power ${id}`);
        }

        if (resourceAvailable < totalCost) {
          alert(`Not enough ${resourceType} for synergy cost! Need ${totalCost}, have ${resourceAvailable}.`);
          document.getElementById(`powerAlignment${id}`).value = charAlignment;
          synergyInput.value = 0;
          document.getElementById(`powerCost${id}`).value = baseCost;
          document.getElementById(`powerCost${id}`).dataset.prevCost = baseCost;
          return;
        }

        if (resourceType === 'Fate Points') {
          document.getElementById('fatePointsCurrent').value = currentFatePoints - totalCost;
        } else {
          document.getElementById(`resourceCurrent${id}`).value = resourceCurrent - totalCost;
        }
        document.getElementById(`powerCost${id}`).value = totalCost;
        document.getElementById(`powerCost${id}`).dataset.prevCost = totalCost;
        document.getElementById(`powerCost${id}`).dataset.resourceType = resourceType;
        console.log(`Deducted ${totalCost} ${resourceType} for synergy update on power ${id}`);
      }
    } catch (e) {
      console.error('Error updating synergy cost:', e);
      alert('Failed to update synergy cost.');
    }
  }

function removePowerField(button) {
  try {
    const powerDiv = button.parentElement;
    // Use data-id attribute to reliably get the power ID
    const id = powerDiv.dataset.id;
    if (!id) {
      console.warn('Power ID not found on div, attempting fallback parsing');
      // Fallback to parsing input IDs
      const costInput = powerDiv.querySelector('input[id^="powerCost"]');
      const nameInput = powerDiv.querySelector('input[id^="powerName"]');
      const match = (costInput && costInput.id.match(/powerCost(\d+)/)) || 
                   (nameInput && nameInput.id.match(/powerName(\d+)/));
      if (match) {
        powerDiv.dataset.id = match[1]; // Cache for future use
      } else {
        throw new Error('Unable to determine power ID');
      }
    }

    // Refund Fate Points
    const prevCostInput = document.getElementById(`powerCost${id}`);
    const prevCost = prevCostInput && prevCostInput.dataset.prevCost ? 
                     parseInt(prevCostInput.dataset.prevCost) : 0;
    if (prevCost > 0) {
      const currentFatePoints = parseInt(document.getElementById('fatePointsCurrent').value) || 0;
      document.getElementById('fatePointsCurrent').value = currentFatePoints + prevCost;
      console.log(`Power removed: id=${id}, Refunded ${prevCost} Fate Points`);
    } else if (prevCostInput) {
      console.log(`Power removed: id=${id}, No Fate Points to refund (prevCost=${prevCost})`);
    } else {
      console.warn(`Power cost input for id=${id} not found, no refund processed`);
    }

    // Remove the power div and update state
    powerDiv.remove();
    powerCounter = Math.max(0, powerCounter - 1);
    updatePowers();
  } catch (e) {
    console.error('Error removing power field:', e);
    alert(`Failed to remove power field: ${e.message}`);
  }
}

  function updatePowers() {
    try {
      const lvl = parseInt(document.getElementById('charLevel').value) || 1;
      const cls = document.getElementById('charClass').value;
      const container = document.getElementById('powersContainer');
      if (!container) {
        console.error('powersContainer not found');
        throw new Error('Powers container element missing');
      }
      console.log(`updatePowers: Level=${lvl}, Class=${cls}, powerCounter=${powerCounter}`);

      // Restrict powers for Levels 1–3 or Faterunner/Harlequin (Changes #5, #10)
      if (lvl <= 3 || ['Faterunner', 'Harlequin'].includes(cls)) {
        container.innerHTML = lvl <= 3 ? '<p>Fatemarked abilities only (Levels 1–3).</p>' : '<p>No powers for Faterunner/Harlequin.</p>';
        powerCounter = 0;
        console.log('Powers restricted, powerCounter reset');
        return;
      }

      // Enforce power cap and PL3 limit for Level 4+ (Change #9)
      let usedPowers = 0;
      const pl3Powers = [];
      for (let i = 1; i <= powerCounter; i++) {
        const powerLevel = document.getElementById(`powerLevel${i}`)?.value;
        if (document.getElementById(`powerName${i}`)) {
          usedPowers++;
          if (powerLevel === 'PL3') pl3Powers.push(i);
        }
      }
      if (usedPowers > lvl) {
        alert(`Too many powers! Max: ${lvl} (Change #9)`);
        powerCounter = Math.min(powerCounter, lvl);
        // Remove excess power fields
        while (container.children.length > lvl) {
          container.removeChild(container.lastChild);
          console.log(`Removed excess power field, new count: ${container.children.length}`);
        }
      }
      if (pl3Powers.length > 1) {
        pl3Powers.slice(1).forEach(i => {
          document.getElementById(`powerLevel${i}`).value = 'PL2';
          alert('Only one PL3 power allowed per session!');
        });
      }

      // Force visibility
      container.style.display = 'block';
      container.offsetHeight; // Trigger reflow
      console.log(`Rendered ${usedPowers} powers, container HTML: ${container.outerHTML}`);
    } catch (e) {
      console.error('Error updating powers:', e);
      alert('Failed to update powers. Check console for details.');
    }
  }

  function addInventoryField() {
    try {
      inventoryCounter++;
      const container = document.getElementById('inventoryContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <input id="itemName${inventoryCounter}" type="text" placeholder="Item Name" style="width: 150px;" title="Name of the item">
        <input id="itemSlots${inventoryCounter}" type="number" min="0" value="1" style="width: 100px;" placeholder="Slots" title="Number of inventory slots used (max 10 total)" onchange="updateInventory()">
        <input id="itemWeight${inventoryCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="Weight (lbs)" title="Weight in pounds" onchange="updateInventory()">
        <input id="itemDesc${inventoryCounter}" type="text" placeholder="Description" style="width: 200px;" title="Item function or notes">
        <input id="itemDurability${inventoryCounter}" type="text" placeholder="Durability" style="width: 100px;" title="Item condition or uses">
        <button class="remove-button" onclick="removeInventoryField(this)">Remove</button>
      `;
      container.appendChild(div);
      updateInventory();
    } catch (e) {
      console.error('Error adding inventory field:', e);
      alert('Failed to add inventory field.');
    }
  }

  function removeInventoryField(button) {
    try {
      button.parentElement.remove();
      inventoryCounter--;
      updateInventory();
    } catch (e) {
      console.error('Error removing inventory field:', e);
      alert('Failed to remove inventory field.');
    }
  }

  function updateInventory() {
    try {
      const str = parseInt(document.getElementById('attrSTR').value) || 10;
      let totalSlots = 0;
      let totalWeight = 0;
      for (let i = 1; i <= inventoryCounter; i++) {
        const slotsInput = document.getElementById(`itemSlots${i}`);
        const weightInput = document.getElementById(`itemWeight${i}`);
        if (slotsInput) totalSlots += parseInt(slotsInput.value) || 0;
        if (weightInput) totalWeight += parseInt(weightInput.value) || 0;
      }
      for (let i = 1; i <= armorCounter; i++) {
        const slotsInput = document.getElementById(`armorSlots${i}`);
        if (slotsInput) totalSlots += parseInt(slotsInput.value) || 0;
      }
      if (totalSlots > 10) alert('Max 10 inventory slots!');
      if (totalWeight > str * 10) alert(`Weight exceeds capacity (${str * 10} lbs)!`);
    } catch (e) {
      console.error('Error updating inventory:', e);
      alert('Failed to update inventory.');
    }
  }

  function addWeaponField() {
    try {
      weaponCounter++;
      const container = document.getElementById('weaponsContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <input id="weaponName${weaponCounter}" type="text" placeholder="Weapon Name" style="width: 150px;" title="Name of the weapon">
        <input id="weaponDamage${weaponCounter}" type="text" placeholder="Damage (e.g., 1d6)" style="width: 100px;" title="Damage dice">
        <input id="weaponRange${weaponCounter}" type="text" placeholder="Range" style="width: 100px;" title="Range in feet">
        <input id="weaponTraits${weaponCounter}" type="text" placeholder="Traits/Effects" style="width: 200px;" title="Special properties">
        <input id="weaponCost${weaponCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="Cost (credits)" title="Cost in credits">
        <button class="remove-button" onclick="removeWeaponField(this)">Remove</button>
      `;
      container.appendChild(div);
    } catch (e) {
      console.error('Error adding weapon field:', e);
      alert('Failed to add weapon field.');
    }
  }

  function removeWeaponField(button) {
    try {
      button.parentElement.remove();
      weaponCounter--;
    } catch (e) {
      console.error('Error removing weapon field:', e);
      alert('Failed to remove weapon field.');
    }
  }

  function addArmorField() {
    try {
      armorCounter++;
      const container = document.getElementById('armorContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <input id="armorName${armorCounter}" type="text" placeholder="Armor Name" style="width: 150px;" title="Name of the armor">
		<input id="armorAC${armorCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="AC Bonus" title="Armor Class bonus" onchange="updateDerivedStats()">
        <input id="armorDEX${armorCounter}" type="text" placeholder="Max DEX" style="width: 100px;" title="Maximum DEX modifier">
        <input id="armorSTR${armorCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="STR Req" title="STR required">
        <input id="armorPenalties${armorCounter}" type="text" placeholder="Penalties" style="width: 200px;" title="Movement or skill penalties">
        <input id="armorSlots${armorCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="Slots" title="Inventory slots used" onchange="updateInventory()">
        <input id="armorCost${armorCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="Cost (credits)" title="Cost in credits">
        <button class="remove-button" onclick="removeArmorField(this)">Remove</button>
      `;
      container.appendChild(div);
      updateDerivedStats();
      updateInventory();
    } catch (e) {
      console.error('Error adding armor field:', e);
      alert('Failed to add armor field.');
    }
  }

  function removeArmorField(button) {
    try {
      button.parentElement.remove();
      armorCounter--;
      updateDerivedStats();
      updateInventory();
    } catch (e) {
      console.error('Error removing armor field:', e);
      alert('Failed to remove armor field.');
    }
  }

  function addDowntimeField() {
    try {
      downtimeCounter++;
      const container = document.getElementById('downtimeContainer');
      const div = document.createElement('div');
      div.className = 'dynamic-group';
      div.innerHTML = `
        <select id="downtimeActivity${downtimeCounter}" onchange="updateDowntimeOutcome(${downtimeCounter})">
          <option value="">Select Activity</option>
          <option value="Crafting">Crafting (DC 15, 1d6 weapon)</option>
          <option value="Training">Training (DC 12, +1 skill point)</option>
          <option value="Research">Research (DC 15, Gain contact)</option>
        </select>
        <input id="downtimeTime${downtimeCounter}" type="number" min="0" value="0" style="width: 100px;" placeholder="Days" title="Days spent">
        <input id="downtimeResources${downtimeCounter}" type="text" placeholder="Resources" style="width: 150px;" title="Credits or materials used">
        <input id="downtimeSkill${downtimeCounter}" type="text" placeholder="Skill Check" style="width: 150px;" title="Skill used">
        <input id="downtimeOutcome${downtimeCounter}" type="text" placeholder="Outcome" style="width: 200px;" title="Result of activity" readonly>
        <button class="remove-button" onclick="removeDowntimeField(this)">Remove</button>
      `;
      container.appendChild(div);
    } catch (e) {
      console.error('Error adding downtime field:', e);
      alert('Failed to add downtime field.');
    }
  }

  function updateDowntimeOutcome(id) {
    try {
      const activity = document.getElementById(`downtimeActivity${id}`).value;
      const outcomes = {
        'Crafting': 'DC 15, Reward: 1d6 weapon',
        'Training': 'DC 12, Reward: +1 skill point',
        'Research': 'DC 15, Reward: Gain contact'
      };
      document.getElementById(`downtimeOutcome${id}`).value = outcomes[activity] || '';
      const skillInput = document.getElementById(`downtimeSkill${id}`);
      skillInput.value = activity === 'Crafting' ? 'Crafting' : activity === 'Training' ? 'Any' : 'Research';
    } catch (e) {
      console.error('Error updating downtime outcome:', e);
      alert('Failed to update downtime outcome.');
    }
  }

  function removeDowntimeField(button) {
    try {
      button.parentElement.remove();
      downtimeCounter--;
    } catch (e) {
      console.error('Error removing downtime field:', e);
      alert('Failed to remove downtime field.');
    }
  }

  function rollDice() {
    try {
    const lvl = parseInt(document.getElementById('characterLevel').value) || 1;
    const cls = document.getElementById('characterClass').value || 'Fatemarked';
    if (cls === 'Fatemarked' && lvl > 3) {
      alert('Fatemarked is only valid for Levels 1–3. Please select an advanced class.');
      return;
    }
    const type = document.getElementById('rollType').value || 'skill';
    const mod = parseInt(document.getElementById('modifier').value) || 0;
    const advSel = document.getElementById('advantage').value || 'none';
    const envAdvantage = document.getElementById('envAdvantage').checked || false;
    const classFeatSelect = document.getElementById('classFeat');
    const dynamicFeatSelects = document.querySelectorAll('.dynamic-feat');
    const feats = [
      {
        value: classFeatSelect.value || 'none',
        tier: parseInt(document.getElementById('classFeatTier').value) || 1
      },
      ...Array.from(dynamicFeatSelects).map(s => ({
        value: s.value,
        tier: parseInt(s.closest('.dynamic-group')?.querySelector('.dynamic-feat-tier')?.value) || 1
      }))
    ].filter(f => f.value !== 'none');
    const customFeat = document.getElementById('customFeat').value?.trim() || '';
    const skillName = ['skill', 'extended', 'opposed', 'extendedOpposed'].includes(type) ?
      document.getElementById('skillName').value || 'none' : null;
    const skillSpec = ['skill', 'extended', 'opposed', 'extendedOpposed'].includes(type) ?
      document.getElementById('skillSpec').value || 'none' : null;
    const advantage = document.getElementById('advantageSelect').value || 'none';
    const advantageTier = parseInt(document.getElementById('advantageTier').value) || 1;
    const disadvantage = document.getElementById('disadvantageSelect').value || 'none';
    const disadvantageTier = parseInt(document.getElementById('disadvantageTier').value) || 1;
    const power = document.getElementById('powerSelect').value || 'none';
    const powerLevel = document.getElementById('powerLevel').value || 'none';
    const paradoxCheckOptIn = document.getElementById('paradoxCheckOptIn')?.checked || false;
    const synergyBonus = document.getElementById('synergyBonus').checked ? 2 : 0;
    const coverConcealment = document.getElementById('coverConcealment').value || 'none';
    const lifestyle = document.getElementById('charLifestyle')?.value || 'Squalid';
    const charData = getCharacterData();
    const now = new Date().toLocaleString('en-US', { timeZone: 'America/New_York' });

    const lifestyleMods = {
      'Luxurious': { Persuasion: 2, Survival: -2 },
      'Comfortable': { Diplomacy: 1 },
      'Modest': {},
      'Squalid': { Survival: 1, Persuasion: -2 }
    };

    const inherentBonuses = {
      'Biomatrix Suit': { 'Technical Expertise': 2, 'Crafting': 2, 'Quantum Engineering': 2 },
      'Continuum Raider': { 'Survival': 2, 'Navigate': 2 },
      'Gunrunner': { 'Ranged Weapons': 2 },
      'Faterunner': { 'Deception': 2 },
      'Harlequin': { 'Deception': 2 },
      'Warrior': { 'Melee Weapon': 2 },
      'Mage': { 'Knowledge': 2, 'Perform': 2 },
      'Shape': { 'Stealth': 2 },
      'Masque': { 'Disguise': 2 },
      'Adventurer': {},
      'Fatemarked': {}
    };

    let naturalRoll = 0;
    let totalRoll = 0;
    let description = '';
    let criticalResult = '';
    let sanityResult = '';
    let paradoxResult = '';
    let levelNote = '';
    let advantageSource = 'Mechanical';
    let effectiveAdvantage = 'none';
    if (advSel === 'disadvantage') {
      effectiveAdvantage = 'disadvantage';
      advantageSource = 'Mechanical (Disadvantage)';
    } else if (advSel === 'advantage' || envAdvantage) {
      effectiveAdvantage = 'advantage';
      advantageSource = advSel === 'advantage' ? 'Mechanical' : 'Environmental';
    }

    function rollD20() {
      const array = new Uint32Array(2);
      crypto.getRandomValues(array);
      const roll1 = 1 + (array[0] % 20);
      const roll2 = 1 + (array[1] % 20);
      if (effectiveAdvantage === 'advantage') {
        description = `Rolls: ${roll1}, ${roll2} (take higher) [${advantageSource}]`;
        return Math.max(roll1, roll2);
      } else if (effectiveAdvantage === 'disadvantage') {
        description = `Rolls: ${roll1}, ${roll2} (take lower) [${advantageSource}]`;
        return Math.min(roll1, roll2);
      }
      description = `Roll: ${roll1}`;
      return roll1;
    }

    function rollD4() {
      const array = new Uint32Array(1);
      crypto.getRandomValues(array);
      return 1 + (array[0] % 4);
    }

    function rollParadoxRisk(powerCost = 0) {
      const paradoxNatural = rollD20();
      const paradoxMod = parseInt(document.getElementById('modifier').value) || 0;
      let paradoxDC = powerLevel === 'PL1' || ['Fate’s Edge', 'Fate’s Influence', 'Fate’s Reach'].includes(powerLevel) ? 15 :
        powerLevel === 'PL2' ? 18 : 22;
      if (power !== 'none') {
        const selectedOption = document.getElementById('powerSelect').querySelector(`option[value="${power}"]`);
        paradoxDC = parseInt(selectedOption?.dataset.dc) || paradoxDC;
      }
      const paradoxTotal = paradoxNatural + paradoxMod + (feats.some(f => f.value === 'Rabbit’s Luck') ? Math.floor(feats.find(f => f.value === 'Rabbit’s Luck').tier / 5) * 2 : 0);
      let paradoxModifiers = [];
      if (paradoxMod !== 0) paradoxModifiers.push(`Modifier ${paradoxMod > 0 ? '+' : ''}${paradoxMod}`);
      if (feats.some(f => f.value === 'Rabbit’s Luck')) paradoxModifiers.push(`Rabbit’s Luck +${Math.floor(feats.find(f => f.value === 'Rabbit’s Luck').tier / 5) * 2}`);
      paradoxResult = `Paradox Risk Check: Rolled ${paradoxNatural}${paradoxModifiers.length ? ' + ' + paradoxModifiers.join(', ') : ''}=${paradoxTotal} vs DC${paradoxDC}. `;
      if (paradoxNatural === 1 || paradoxTotal < paradoxDC - 10) {
        paradoxResult += cls === 'Faterunner' || cls === 'Harlequin' ? 'Epic Failure: Minor Rift (AC 14, 20 Health)!' : 'Epic Failure: Dimensional Beast (AC 15, 30 Health)!';
        const sanityLoss = rollD4();
        document.getElementById('sanity').value = parseInt(document.getElementById('sanity').value) - sanityLoss;
        sanityResult = `Sanity Loss: -${sanityLoss} due to epic paradox!`;
        addParadoxPoint();
      } else if (paradoxTotal < paradoxDC) {
        if (paradoxTotal < paradoxDC - 5) {
          paradoxResult += cls === 'Faterunner' || cls === 'Harlequin' ? 'Major Failure: Faint Shimmer (No Portal)!' : 'Major Failure: Minor Rift (Portal with Whispers)!';
          addParadoxPoint();
        } else {
          paradoxResult += cls === 'Faterunner' || cls === 'Harlequin' ? 'Minor Failure: Minor Anomaly (-1 Penalty for 1 Encounter)!' : 'Minor Failure: Temporal Backlash (-2 Penalty for 1 Encounter)!';
          addParadoxPoint();
        }
      } else {
        paradoxResult += 'Stable Continuum!';
        hasParadoxSuccess = true;
      }
      if (powerCost > 0) {
        totalResourcesUsedInSession += powerCost;
      }
    }

    function confirmCritical() {
      const confirmRoll = rollD20();
      const confirmTotal = confirmRoll + mod + (['attack', 'disarm', 'grapple', 'trip'].includes(type) ? getBAB(lvl, cls) : 0);
      return confirmTotal >= (parseInt(document.getElementById('ac').value) || 15);
    }

    function checkEpicFail(dc, total, isDimensional = false) {
      if (naturalRoll !== 1) return { isEpicFail: false, result: '' };
      const threshold = dc >= 15 ? 5 : 10;
      if (total >= dc - threshold) return { isEpicFail: false, result: '' };

      const canSpendFate = lvl >= 4 && parseInt(document.getElementById('fatePointsCurrent').value) >= 1;
      const canUseInnate = lvl <= 3 && !localStorage.getItem('ability_Fate’s Edge');
      if (canSpendFate || canUseInnate) {
        const useResource = confirm(`Epic Fail Check triggered! Use ${canSpendFate ? '1 Fate Point' : 'Fate’s Edge'} to avoid?`);
        if (useResource) {
          if (canSpendFate) {
            document.getElementById('fatePointsCurrent').value = parseInt(document.getElementById('fatePointsCurrent').value) - 1;
            totalResourcesUsedInSession += 1;
            if (totalResourcesUsedInSession > lvl || (totalResourcesUsedInSession > lvl + 1 && (totalResourcesUsedInSession - lvl - 1) % 2 === 0)) {
              rollParadoxRiskForFatePoint(1);
            }
          } else {
            localStorage.setItem('ability_Fate’s Edge', 'used');
          }
          return { isEpicFail: false, result: 'Standard Critical Failure: -1 to skill checks for session.' };
        }
      }

      const reroll = rollD20();
      if (reroll === 1) {
        let consequence = '';
        if (dc >= 20) {
          consequence = isDimensional ?
            'Major Setback: Minor rift (INT DC 18, summons beast AC 12, 20 Health, 1d6 damage). Paradox Risk: INT/CHA DC 18, -2 penalty or anomaly.' :
            'Major Setback: Lose 1d4 Sanity (WIS DC 15 to resist).';
          if (isDimensional) rollParadoxRisk();
        } else if (dc >= 15) {
          consequence = isDimensional ?
            'Moderate Setback: Equipment breaks (Technical Expertise DC 15 to repair). Paradox Risk: INT/CHA DC 15, -1 penalty for 1 encounter.' :
            'Moderate Setback: NPC hostile (Persuasion DC 15 to de-escalate).';
          if (isDimensional) rollParadoxRisk();
        } else {
          consequence = 'Minor Setback: Equipment jams (-1 to skill checks for 1 encounter).';
          if (isDimensional) rollParadoxRisk();
        }
        const sanityLoss = dc >= 20 ? rollD4() : 0;
        if (sanityLoss) {
          document.getElementById('sanity').value = parseInt(document.getElementById('sanity').value) - sanityLoss;
          sanityResult = `Sanity Loss: -${sanityLoss}!`;
        }
        return { isEpicFail: true, result: `Epic Fail Confirmed! ${consequence}` };
      } else {
        const rerollTotal = reroll + mod + (type === 'skill' ? parseInt(document.getElementById('skillRank').value) || 0 : 0);
        if (rerollTotal >= dc - 5) {
          return { isEpicFail: false, result: 'Normal Failure.' };
        }
        return { isEpicFail: false, result: 'Standard Critical Failure: -1 to skill checks for session.' };
      }
    }

    if (['skill', 'attack', 'sanity', 'saving', 'initiative', 'paradox', 'hazard', 'extended', 'opposed', 'extendedOpposed', 'disarm', 'grapple', 'trip'].includes(type)) {
      naturalRoll = rollD20();
      let extraModifier = 0;
      if (['skill', 'extended'].includes(type) && skillName !== 'none') {
        extraModifier = charData ? charData.skills.find(s => s.name === skillName)?.rank || 0 :
          parseInt(document.getElementById('skillRank').value) || 0;
        if (skillSpec !== 'none') extraModifier += 2; // Specialization bonus
      }
      if (['attack', 'disarm', 'grapple', 'trip'].includes(type)) extraModifier = getBAB(lvl, cls);
      totalRoll = naturalRoll + mod + extraModifier + synergyBonus;

      let modifiers = [];
      if (mod !== 0 && skillName !== 'none') modifiers.push(`${skillName} Modifier ${mod > 0 ? '+' : ''}${mod}`);
      if (extraModifier !== 0) {
        if (['skill', 'extended'].includes(type)) {
          if (skillSpec !== 'none') modifiers.push(`Specialization (${skillSpec}) +2`);
          modifiers.push(`Skill Rank +${extraModifier - (skillSpec !== 'none' ? 2 : 0)}`);
        } else if (['attack', 'disarm', 'grapple', 'trip'].includes(type)) {
          modifiers.push(`BAB +${extraModifier}`);
        }
      }
      if (synergyBonus !== 0) modifiers.push(`Synergy Bonus +${synergyBonus}`);
      if (skillName !== 'none' && lifestyleMods[lifestyle][skillName]) {
        totalRoll += lifestyleMods[lifestyle][skillName];
        modifiers.push(`Lifestyle (${lifestyle}) ${lifestyleMods[lifestyle][skillName] > 0 ? '+' : ''}${lifestyleMods[lifestyle][skillName]}`);
      }
      if (skillName !== 'none' && inherentBonuses[cls] && inherentBonuses[cls][skillName]) {
        totalRoll += inherentBonuses[cls][skillName];
        modifiers.push(`${cls} Inherent +${inherentBonuses[cls][skillName]}`);
      }
      if (cls === 'Adventurer' && feats.some(f => f.value === 'Jack of All Trades')) {
        totalRoll += 1;
        modifiers.push('Jack of All Trades +1');
      }
      if (cls === 'Harlequin' && skillName === 'Deception' && localStorage.getItem('ability_Illusion Weave')) {
        totalRoll += 2;
        modifiers.push('Illusion Weave +2');
      }

      // Apply advantage modifiers
      if (advantage !== 'none') {
        const advData = advantagesList.find(a => a.name === advantage);
        if (advData) {
          if (advData.name === 'Sniper' && ['attack', 'disarm'].includes(type)) {
            const concentrationRank = charData ? charData.skills.find(s => s.name === 'Concentration')?.rank || 0 : 0;
            totalRoll += concentrationRank;
            modifiers.push(`Sniper +${concentrationRank}`);
          } else if (advData.name === 'Feint' && ['attack', 'disarm', 'grapple', 'trip'].includes(type)) {
            totalRoll += advantageTier;
            modifiers.push(`Feint +${advantageTier}`);
          } else if (advData.name === 'Reckless Abandon' && ['attack'].includes(type)) {
            totalRoll += advantageTier;
            modifiers.push(`Reckless Abandon +${advantageTier}`);
          } else if (advData.name === 'Animal Empathy' && skillName === 'Animal Handling') {
            totalRoll += advantageTier;
            modifiers.push(`Animal Empathy +${advantageTier}`);
          } else if (advData.name === 'Attractive' && ['Deception', 'Diplomacy', 'Persuade'].includes(skillName)) {
            totalRoll += advantageTier;
            modifiers.push(`Attractive +${advantageTier}`);
          } else if (advData.name === 'Melee Expert' && skillName === 'Melee Weapon') {
            totalRoll += advantageTier;
            modifiers.push(`Melee Expert +${advantageTier}`);
          } else if (advData.name === 'Defensive Fighter' && ['attack'].includes(type)) {
            totalRoll -= advantageTier;
            modifiers.push(`Defensive Fighter -${advantageTier}`);
          } else if (advData.name === 'Recall' && skillName === 'Knowledge') {
            totalRoll += advantageTier;
            modifiers.push(`Recall +${advantageTier}`);
          } else if (advData.name === 'Evasion' && type === 'saving' && document.getElementById('savingType').value === 'reflex') {
            totalRoll += advantageTier;
            modifiers.push(`Evasion +${advantageTier}`);
          } else if (advData.name === 'Enamor' && ['Deception', 'Persuade'].includes(skillName)) {
            totalRoll += advantageTier;
            modifiers.push(`Enamor +${advantageTier}`);
          } else if (advData.name === 'Fearless' && type === 'sanity') {
            totalRoll += 2;
            modifiers.push('Fearless +2');
          } else if (advData.name === 'Tireless' && type === 'saving' && document.getElementById('savingType').value === 'fortitude') {
            totalRoll += advantageTier;
            modifiers.push(`Tireless +${advantageTier}`);
          } else if (advData.name === 'Improved Critical' && ['attack', 'disarm', 'grapple', 'trip'].includes(type)) {
            totalRoll += advantageTier;
            modifiers.push(`Improved Critical +${advantageTier}`);
          } else if (advData.name === 'Improved Disarm' && type === 'disarm') {
            totalRoll += 2;
            modifiers.push('Improved Disarm +2');
          } else if (advData.name === 'Improved Initiative' && type === 'initiative') {
            totalRoll += advantageTier;
            modifiers.push(`Improved Initiative +${advantageTier}`);
          } else if (advData.name === 'Improved Defensive' && type === 'grapple') {
            totalRoll += advantageTier * 2;
            modifiers.push(`Improved Defensive +${advantageTier * 2}`);
          } else if (advData.name === 'MacGyver' && ['Crafting', 'Technical Expertise'].includes(skillName)) {
            totalRoll += 2;
            modifiers.push('MacGyver +2');
          } else if (advData.name === 'Multilingual' && skillName === 'Language') {
            totalRoll += advantageTier;
            modifiers.push(`Multilingual +${advantageTier}`);
          } else if (advData.name === 'Rabbit’s Luck' && type === 'paradox') {
            const rabbitBonus = Math.floor(advantageTier / 5) * 2;
            totalRoll += rabbitBonus;
            modifiers.push(`Rabbit’s Luck +${rabbitBonus}`);
          } else if (advData.name === 'Surgical Precision' && ['attack', 'disarm'].includes(type)) {
            totalRoll += advantageTier;
            modifiers.push(`Surgical Precision +${advantageTier}`);
          } else if (advData.name === 'Ranged Weapons Mastery' && skillName === 'Ranged Weapons') {
            totalRoll += advantageTier;
            modifiers.push(`Ranged Weapons Mastery +${advantageTier}`);
          }
        }
      }

      // Apply disadvantage penalties
      if (disadvantage !== 'none') {
        const disData = disadvantagesList.find(d => d.name === disadvantage);
        if (disData) {
          if (disData.name === 'Nearsighted' && ['Perception', 'Ranged Weapons'].includes(skillName)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Nearsighted -${disadvantageTier}`);
          } else if (disData.name === 'Social Anxiety' && ['Deception', 'Diplomacy', 'Persuade'].includes(skillName)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Social Anxiety -${disadvantageTier}`);
          } else if (disData.name === 'Bum Knee' && skillName === 'Acrobatics' && skillSpec === 'Tumbling') {
            totalRoll -= disadvantageTier;
            modifiers.push(`Bum Knee -${disadvantageTier}`);
          } else if (disData.name === 'Chronic Stutter' && ['Persuasion', 'Perform'].includes(skillName)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Chronic Stutter -${disadvantageTier}`);
          } else if (disData.name === 'Weak Grip' && skillName === 'Melee Weapon') {
            totalRoll -= disadvantageTier;
            modifiers.push(`Weak Grip -${disadvantageTier}`);
          } else if (disData.name === 'Chronic Back Pain' && type === 'saving' && document.getElementById('savingType').value === 'reflex') {
            totalRoll -= disadvantageTier;
            modifiers.push(`Chronic Back Pain -${disadvantageTier}`);
          } else if (disData.name === 'Migraines' && ['Knowledge', 'Cryptography'].includes(skillName)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Migraines -${disadvantageTier}`);
          } else if (disData.name === 'Asthma' && type === 'saving' && document.getElementById('savingType').value === 'fortitude') {
            totalRoll -= disadvantageTier;
            modifiers.push(`Asthma -${disadvantageTier}`);
          } else if (disData.name === 'Impulsiveness' && skillName === 'Insight') {
            totalRoll -= 2;
            modifiers.push('Impulsiveness -2');
          } else if (disData.name === 'Insomnia' && type === 'saving' && document.getElementById('savingType').value === 'fortitude') {
            totalRoll -= disadvantageTier;
            modifiers.push(`Insomnia -${disadvantageTier}`);
          } else if (disData.name === 'Shaky Hands' && ['Sleight of Hand', 'Lockpicking'].includes(skillName)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Shaky Hands -${disadvantageTier}`);
          } else if (disData.name === 'Old Shoulder Injury' && ['disarm', 'grapple'].includes(type)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Old Shoulder Injury -${disadvantageTier}`);
          } else if (disData.name === 'Poor Reaction Time' && type === 'saving' && document.getElementById('savingType').value === 'reflex') {
            totalRoll -= disadvantageTier;
            modifiers.push(`Poor Reaction Time -${disadvantageTier}`);
          } else if (disData.name === 'Self-Doubt' && ['Persuasion', 'Deception'].includes(skillName)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Self-Doubt -${disadvantageTier}`);
          } else if (disData.name === 'Overcautious Nature' && type === 'initiative') {
            totalRoll -= 2;
            modifiers.push('Overcautious Nature -2');
          } else if (disData.name === 'Dyslexia' && ['Knowledge', 'Research'].includes(skillName)) {
            totalRoll -= disadvantageTier;
            modifiers.push(`Dyslexia -${disadvantageTier}`);
          } else if (disData.name === 'Low Willpower' && type === 'saving' && document.getElementById('savingType').value === 'willpower') {
            totalRoll -= disadvantageTier;
            modifiers.push(`Low Willpower -${disadvantageTier}`);
          }
        }
      }

      // Apply power effects for paradox rolls
      let powerCost = 0;
      if (type === 'paradox' && power !== 'none') {
        const selectedOption = document.getElementById('powerSelect').querySelector(`option[value="${power}"]`);
        powerCost = parseInt(selectedOption?.dataset.cost) || 0;
        if (powerCost > 0 && parseInt(document.getElementById('fatePointsCurrent').value) < powerCost) {
          alert(`Need ${powerCost} Fate Point(s) for ${power}!`);
          return;
        }
      }

      if (coverConcealment === 'cover' && !feats.some(f => ['Sniper', 'Surgical Precision'].includes(f.value)) && advantage !== 'Surgical Precision') {
        totalRoll -= 4;
        modifiers.push('Cover -4');
      }
      if (coverConcealment === 'concealment' && !feats.some(f => ['Sniper', 'Surgical Precision'].includes(f.value)) && advantage !== 'Surgical Precision') {
        const missChance = Math.random() < 0.2 ? -2 : 0;
        totalRoll += missChance;
        if (missChance) modifiers.push('Concealment -2');
      }

      feats.forEach(f => {
        if (f.value === 'Fatemarked Agility' && skillName && ['Acrobatics', 'Escape Artist', 'Pilot', 'Riding', 'Sleight of Hand', 'Stealth'].includes(skillName)) {
          totalRoll += 2;
          modifiers.push('Fatemarked Agility +2');
        }
        if (f.value === 'Dimensional Instinct' && skillName && ['Insight', 'Investigate', 'Survival'].includes(skillName) && type === 'skill') {
          totalRoll += 3;
          modifiers.push('Dimensional Instinct +3');
        }
        if (f.value === 'Mystic Resonance' && skillName && ['Artistic Expression', 'Deception', 'Perform', 'Persuade'].includes(skillName)) {
          totalRoll += 2;
          modifiers.push('Mystic Resonance +2');
        }
        if (f.value === 'Circuit Intuition' && skillName && ['Crafting', 'Technical Expertise', 'Quantum Engineering'].includes(skillName)) {
          totalRoll += 2;
          modifiers.push('Circuit Intuition +2');
        }
        if (f.value === 'Iron Psyche' && type === 'sanity') {
          totalRoll += 2;
          modifiers.push('Iron Psyche +2');
        }
        if (f.value === 'Scholar’s Insight' && skillName && skillName === 'Knowledge') {
          totalRoll += 3;
          modifiers.push('Scholar’s Insight +3');
        }
        if (f.value === 'Streetwise Contact' && skillName && skillName === 'Streetwise') {
          totalRoll += 3;
          modifiers.push('Streetwise Contact +3');
        }
        if (f.value === 'Artisan’s Craft' && skillName && skillName === 'Crafting') {
          totalRoll += 3;
          modifiers.push('Artisan’s Craft +3');
        }
        if (f.value === 'Veteran’s Grit' && skillName && skillName === 'Intimidate') {
          totalRoll += 4;
          modifiers.push('Veteran’s Grit +4');
        }
        if (f.value === 'Performer’s Flair' && skillName && skillName === 'Perform') {
          totalRoll += 3;
          modifiers.push('Performer’s Flair +3');
        }
        if (f.value === 'custom' && customFeat) {
          modifiers.push(`Custom Feat (${customFeat})`);
        }
      });

      let dc = 0;
      if (['skill', 'sanity', 'saving', 'hazard'].includes(type)) dc = parseInt(document.getElementById('dc').value) || 10;
      if (type === 'paradox') {
        const sel = document.getElementById('paradoxDC').value;
        dc = sel === 'custom' ? (parseInt(document.getElementById('customParadoxDC').value) || 15) : parseInt(sel);
      }
      if (type === 'extended') dc = parseInt(document.getElementById('cumulativeDC').value) || 30;
      if (['opposed', 'extendedOpposed', 'grapple'].includes(type)) dc = parseInt(document.getElementById('opponentRoll').value) || 10;
      if (['attack', 'disarm', 'trip'].includes(type)) dc = parseInt(document.getElementById('ac').value) || 15;

      description += `<br>Modifiers: ${modifiers.length ? modifiers.join(', ') : 'None'}<br>Total: ${totalRoll}`;

      let flavorText = '';
      if (cls === 'Fatemarked' && ['skill', 'attack', 'saving'].includes(type) && effectiveAdvantage === 'advantage') {
        flavorText = lvl >= 3 ? 'Fate’s Reach bends reality!' : lvl >= 2 ? 'Fate’s intuition guides your hand!' : 'Fate’s edge shines through!';
      } else if (cls === 'Biomatrix Suit' && ['attack', 'skill'].includes(type)) {
        flavorText = totalRoll >= dc ? 'Order’s precision prevails!' : 'Tech falters in chaos!';
      } else if (cls === 'Continuum Raider' && ['attack', 'skill'].includes(type)) {
        flavorText = totalRoll >= dc ? 'Chaos fuels your mutation!' : 'The Continuum resists!';
      } else if (cls === 'Gunrunner' && type === 'attack') {
        flavorText = totalRoll >= dc ? 'Chronometric aim strikes true!' : 'Shot goes wide!';
      } else if (cls === 'Faterunner' && totalRoll >= dc) {
        flavorText = 'Luck turns the tide!';
      } else if (cls === 'Harlequin' && totalRoll >= dc) {
        flavorText = 'Illusion weaves success!';
      } else if (cls === 'Warrior' && type === 'attack') {
        flavorText = totalRoll >= dc ? 'Chi empowers your blow!' : 'Balance wavers!';
      } else if (cls === 'Mage' && ['skill', 'saving'].includes(type)) {
        flavorText = totalRoll >= dc ? 'Arcane mastery shines!' : 'Magic flickers!';
      } else if (cls === 'Shape' && ['skill', 'attack'].includes(type)) {
        flavorText = totalRoll >= dc ? 'Pathos reshapes reality!' : 'The Darkwell stirs!';
      } else if (cls === 'Masque' && ['skill', 'saving'].includes(type)) {
        flavorText = totalRoll >= dc ? 'Pact holds strong!' : 'Revenants whisper!';
      } else if (cls === 'Adventurer' && totalRoll >= dc) {
        flavorText = 'Versatility triumphs!';
      }

      if (type === 'skill') {
        if (skillName === 'none') {
          alert('Please select a skill!');
          return;
        }
        const isDimensional = powerLevel !== 'none' && !['Fate’s Edge', 'Fate’s Influence', 'Fate’s Reach'].includes(powerLevel);
        const epicFail = checkEpicFail(dc, totalRoll, isDimensional);
        if (epicFail.isEpicFail) {
          criticalResult = epicFail.result;
        } else if (naturalRoll === 20 && skillName && !skillCriticalTracker[skillName]) {
          skillCriticalTracker[skillName] = true;
          criticalResult = `Critical Success in ${skillName}${skillSpec !== 'none' ? ` (${skillSpec})` : ''}! Gain a skill point! ${flavorText}`;
          if (isDimensional) rollParadoxRisk();
        } else if (naturalRoll === 1 && !epicFail.isEpicFail) {
          criticalResult = epicFail.result || `Critical Failure: -1 to ${skillName} checks for session!`;
          if (isDimensional) rollParadoxRisk();
        } else if (totalRoll >= dc + 5) {
          criticalResult = `Triumphant Success! ${flavorText}`;
        } else if (totalRoll >= dc) {
          criticalResult = `Success! ${flavorText}`;
        } else {
          criticalResult = 'Failure!';
        }
      }
      if (['attack', 'disarm', 'grapple', 'trip'].includes(type)) {
        if (naturalRoll === 1) {
          const epicFail = checkEpicFail(dc, totalRoll);
          criticalResult = epicFail.isEpicFail ? epicFail.result : 'Critical Miss: -1 to attack rolls for session!';
          description += type === 'grapple' ? ` vs Opponent ${dc}` : ` vs AC ${dc}`;
        } else {
          let critRange = 20;
          if (feats.some(f => f.value === 'Improved Critical') || advantage === 'Improved Critical') {
            critRange = 20 - (feats.find(f => f.value === 'Improved Critical')?.tier || advantageTier);
            modifiers.push(`Improved Critical (Range ${critRange}-20)`);
          }
          if (naturalRoll >= critRange && confirmCritical()) {
            criticalResult = `Confirmed Critical Hit! ${flavorText}`;
          } else if (totalRoll >= dc) {
            criticalResult = type === 'attack' ? `Hit! ${flavorText}` : `${type.charAt(0).toUpperCase() + type.slice(1)} Success! ${flavorText}`;
          } else {
            criticalResult = type === 'attack' ? 'Miss!' : `${type.charAt(0).toUpperCase() + type.slice(1)} Failed!`;
          }
          description += type === 'grapple' ? ` vs Opponent ${dc}` : ` vs AC ${dc}`;
        }
      }
      if (type === 'sanity' || type === 'saving') {
        const epicFail = checkEpicFail(dc, totalRoll);
        if (epicFail.isEpicFail) {
          sanityResult = epicFail.result;
        } else {
          sanityResult = `${type === 'sanity' ? 'Sanity' : 'Save'}: ${naturalRoll}${modifiers.length ? ' + ' + modifiers.join(', ') : ''}=${totalRoll} vs DC${dc}. ${flavorText}`;
        }
      }
      if (type === 'paradox') {
        const epicFail = checkEpicFail(dc, totalRoll, true);
        if (powerCost > 0) {
          document.getElementById('fatePointsCurrent').value = parseInt(document.getElementById('fatePointsCurrent').value) - powerCost;
        }
        const shouldCheckParadox = (cls === 'Faterunner' || cls === 'Harlequin') ?
          (powerLevel === 'PL2' || powerLevel === 'PL3' || power !== 'none') && paradoxCheckOptIn :
          totalResourcesUsedInSession + powerCost > lvl || (totalResourcesUsedInSession + powerCost > lvl + 1 && (totalResourcesUsedInSession + powerCost - lvl - 1) % 2 === 0);
        if (shouldCheckParadox) {
          if (epicFail.isEpicFail) {
            paradoxResult = epicFail.result;
          } else if (naturalRoll === 1 && !epicFail.isEpicFail) {
            paradoxResult = cls === 'Faterunner' || cls === 'Harlequin' ? 'Critical Failure: Minor Rift (AC 14, 20 Health)!' : 'Critical Failure: Dimensional Beast (AC 15, 30 Health)!';
            const sanityLoss = rollD4();
            document.getElementById('sanity').value = parseInt(document.getElementById('sanity').value) - sanityLoss;
            sanityResult = `Sanity Loss: -${sanityLoss} due to critical paradox!`;
            addParadoxPoint();
          } else if (totalRoll < dc) {
            paradoxResult = cls === 'Faterunner' || cls === 'Harlequin' ? 'Minor Backlash (-1)!' : 'Temporal Backlash (-2)!';
            addParadoxPoint();
          } else {
            paradoxResult = `Stable Continuum! ${flavorText}`;
            hasParadoxSuccess = true;
          }
        } else {
          paradoxResult = powerCost > 0 ? `No paradox check required for ${power}.` : 'No paradox check required.';
        }
        if (powerCost > 0) {
          totalResourcesUsedInSession += powerCost;
        }
        description += ` vs DC ${dc}`;
      }
      if (type === 'hazard') {
        const epicFail = checkEpicFail(dc, totalRoll);
        if (epicFail.isEpicFail) {
          paradoxResult = epicFail.result;
        } else {
          paradoxResult = totalRoll >= dc ? `Navigated Hazard! ${flavorText}` : 'Hazard Overwhelms!';
        }
        description += ` vs DC ${dc}`;
      }
      if (type === 'extended') {
        if (skillName === 'none') {
          alert('Please select a skill!');
          return;
        }
        const isDimensional = powerLevel !== 'none' && !['Fate’s Edge', 'Fate’s Influence', 'Fate’s Reach'].includes(powerLevel);
        const epicFail = checkEpicFail(dc, totalRoll, isDimensional);
        if (epicFail.isEpicFail) {
          criticalResult = epicFail.result;
        } else {
          extendedProgress += totalRoll;
          criticalResult = `Progress: ${extendedProgress}/${dc} ${extendedProgress >= dc ? `- Success! ${flavorText}` : ''}`;
          if (isDimensional) rollParadoxRisk();
        }
      }
      if (type === 'opposed' || type === 'extendedOpposed') {
        if (skillName === 'none') {
          alert('Please select a skill!');
          return;
        }
        const isDimensional = powerLevel !== 'none' && !['Fate’s Edge', 'Fate’s Influence', 'Fate’s Reach'].includes(powerLevel);
        const epicFail = checkEpicFail(dc, totalRoll, isDimensional);
        if (epicFail.isEpicFail) {
          criticalResult = epicFail.result;
        } else if (type === 'extendedOpposed') {
          extendedProgress += totalRoll;
          criticalResult = `Progress: ${extendedProgress}/${dc} ${extendedProgress >= dc ? `- Success! ${flavorText}` : ''}`;
          if (isDimensional) rollParadoxRisk();
        } else {
          criticalResult = totalRoll >= dc ? `Outperformed! (${totalRoll} vs ${dc}) ${flavorText}` : `Opponent Prevails! (${totalRoll} vs ${dc})`;
        }
      }
      if (type === 'initiative') {
        criticalResult = `Initiative: ${totalRoll} ${flavorText}`;
      }
    } else {
      let notation = type === 'damage' || type === 'nonLethal' ? document.getElementById('damageDice').value : document.getElementById('customDice').value || '1d6';
      const match = notation.match(/(\d+)d(\d+)/);
      if (!match) return alert('Invalid dice notation.');
      const [, numDice, dieType] = match.map(Number);
      let rolls = [];
      for (let i = 0; i < numDice; i++) {
        const array = new Uint32Array(1);
        crypto.getRandomValues(array);
        rolls.push(1 + (array[0] % dieType));
      }
      totalRoll = rolls.reduce((sum, val) => sum + val, 0) + mod - (type === 'nonLethal' ? 2 : 0);
      let modifiers = [];
      if (mod !== 0) modifiers.push(`Modifier ${mod > 0 ? '+' : ''}${mod}`);
      if (type === 'nonLethal') modifiers.push('Non-Lethal -2');
      if (advantage === 'Sniper' && type === 'damage') {
        const concentrationRank = charData ? charData.skills.find(s => s.name === 'Concentration')?.rank || 0 : 0;
        totalRoll += concentrationRank;
        modifiers.push(`Sniper +${concentrationRank}`);
      }
      description = `Rolls: ${rolls.join(', ')}<br>Modifiers: ${modifiers.length ? modifiers.join(', ') : 'None'}<br>Total: ${totalRoll}`;
      criticalResult = type === 'nonLethal' ? 'Non-Lethal Strike!' : 'Damage Dealt!';
    }

    if ([3, 4, 6, 8, 10, 12, 14].includes(lvl)) levelNote += `Feat Available!`;
    else {
      const nextFeat = [3, 4, 6, 8, 10, 12, 14].find(x => x > lvl);
      if (nextFeat) levelNote += `Next feat at Level ${nextFeat}.`;
    }

    document.getElementById('results').classList.remove('hidden');
    document.getElementById('rollResult').innerHTML = description;
    document.getElementById('rollResult').setAttribute('aria-label', `Roll result: ${description.replace(/<br>/g, ', ')}`);
    document.getElementById('criticalResult').innerHTML = criticalResult;
    document.getElementById('criticalResult').setAttribute('aria-label', `Critical result: ${criticalResult}`);
    document.getElementById('sanityResult').innerHTML = sanityResult;
    document.getElementById('sanityResult').setAttribute('aria-label', `Sanity result: ${sanityResult}`);
    document.getElementById('paradoxResult').innerHTML = paradoxResult;
    document.getElementById('paradoxResult').setAttribute('aria-label', `Paradox result: ${paradoxResult}`);
    document.getElementById('levelNote').innerHTML = levelNote;
    document.getElementById('levelNote').setAttribute('aria-label', `Level note: ${levelNote}`);

    const historyList = document.getElementById('historyList');
    const li = document.createElement('li');
    li.innerHTML = `${now} — ${type.charAt(0).toUpperCase() + type.slice(1)}:<br>${description}${criticalResult ? `<br>${criticalResult}` : ''}${sanityResult ? `<br>${sanityResult}` : ''}${paradoxResult ? `<br>${paradoxResult}` : ''}${levelNote ? `<br>${levelNote}` : ''}`;
    historyList.prepend(li);
  } catch (e) {
    console.error('Error rolling dice:', e);
    alert('Failed to roll dice. Please check inputs.');
  }
}

  function clearFields() {
    try {
      document.getElementById('results').classList.add('hidden');
      ['rollResult', 'criticalResult', 'sanityResult', 'paradoxResult', 'levelNote', 'historyList', 'gmReferenceOutput'].forEach(id => {
        document.getElementById(id).innerHTML = '';
      });
      skillCriticalTracker = {};
      hasParadoxSuccess = false;
      extendedProgress = 0;
      fatePointsUsedInEncounter = 0; // Reset encounter tracking
      resetInputs();
      localStorage.clear();
    } catch (e) {
      console.error('Error clearing fields:', e);
      alert('Failed to clear fields.');
    }
  }

  function generateReality() {
    try {
      const topographies = [
        'Floating Islands - DC 15 Acrobatics to cross, -2 DEX on failure.',
        'Crystalline Caverns - DC 15 WIS to navigate, +2 Perception.',
        'Endless Ocean - DC 15 Swim, +2 Survival for aquatic resources.',
        'Fractured Void - DC 15 DEX to move, -2 checks on failure.',
        'Lush Jungle - DC 15 Survival, +2 Treat Injury with herbs.',
        'Ashen Wasteland - DC 15 CON to avoid exhaustion, -2 checks.',
        'Metallic Cityscape - DC 15 Technical Expertise, +2 Intimidate.',
        'Prismatic Plains - DC 15 WIS to avoid disorientation, +2 CHA.',
        'Frozen Tundra - DC 15 CON to endure cold, -2 DEX.',
        'Living Mountain - DC 15 Insight, +2 Knowledge.'
      ];
      const cosmicBalances = [
        'Balance - +2 Persuasion with locals.',
        'Growth (Chaos/Good) - +2 CHA, -2 INT.',
        'Discord (Chaos/Evil) - +2 CHA, -2 WIS.',
        'Oppression (Order/Evil) - +2 INT, -2 CHA.',
        'Reason (Order/Good) - +2 INT, -2 CON.'
      ];
      const techMagic = [
        'Technological - DC 15 Technical Expertise, +2 tech.',
        'Magical - DC 15 Knowledge, +2 magic.',
        'Hybrid - DC 15 Technical Expertise/CHA, +1 tech/magic.',
        'Primitive - DC 15 Survival, +2 physical.'
      ];
      const populationDensities = ['Dense - DC 15 Persuasion, +2 social.', 'Moderate - No modifiers.', 'Sparse - DC 15 Survival, -2 Persuasion.'];
      const dominantLifeForms = ['Humanoid - +2 Persuasion.', 'Beast - DC 15 Animal Handling, +2 Survival.', 'Aberrant - DC 15 WIS, -2 checks or +2 CHA.'];
      const societalLevels = [
        'Tribal - DC 15 Insight, +2 Survival.',
        'Feudal - DC 15 Persuasion, +2 Intimidate.',
        'Anarchic - DC 15 CHA, +2 Deception.',
        'Democratic - DC 15 Persuasion, +2 social.',
        'Technocratic - DC 15 Technical Expertise, +2 INT.'
      ];
      const otherTraits = ['Stable - +2 WIS.', 'Unstable - DC 15 INT, -2 checks.', 'Paradox Nexus - DC 15 INT, -2 checks or +2 magic.'];
      const quirks = [
        'Colorblind Sky - DC 15 WIS, -1 checks.',
        'Whispering Shadows - DC 15 Insight, +2 Deception.',
        'Sentient Flora - DC 15 CHA, +2 Animal Handling.',
        'Reversed Gravity - DC 15 DEX, +2 Acrobatics.',
        'Eternal Festival - +2 Perform, -1 Stealth.',
        'Mirror Realities - DC 15 WIS, -2 checks.',
        'Singing Crystals - DC 15 Knowledge, +2 magic.',
        'Ghostly Visitors - DC 15 WIS, +2 Insight.',
        'Temporal Echoes - DC 15 INT, +2 Knowledge.',
        'Primordial Mark - +2 tech, -2 CHA.'
      ];

      const rollD10 = () => Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] % 10);
      const reality = {
        Topography: topographies[rollD10()],
        'Cosmic Balance': cosmicBalances[rollD10() % 5],
        'Technology/Magic': techMagic[rollD10() % 4],
        'Population Density': populationDensities[rollD10() % 3],
        'Dominant Life Form': dominantLifeForms[rollD10() % 3],
        'Societal Level': societalLevels[rollD10() % 5],
        'Other Traits': otherTraits[rollD10() % 3],
        Quirks: quirks[rollD10()]
      };

      let output = '<strong>Wondrous Realities</strong><br>';
      for (const [key, value] of Object.entries(reality)) output += `<strong>${key}:</strong> ${value}<br>`;
      document.getElementById('gmReferenceOutput').innerHTML = output;
    } catch (e) {
      console.error('Error generating reality:', e);
      alert('Failed to generate reality.');
    }
  }

  function generateFixedPoint() {
    try {
      const types = ['Event (e.g., Battle of Riftgate)', 'Person (e.g., Rift King)', 'Location (e.g., Nexus Spire)'];
      const statuses = ['Stable', 'Threatened', 'Altered'];
      const point = {
        Type: types[Math.floor(Math.random() * types.length)],
        Description: prompt('Enter description (e.g., Battle of Riftgate)') || 'Unnamed',
        Status: statuses[Math.floor(Math.random() * statuses.length)],
        DC: 15 + Math.floor(Math.random() * 10)
      };
      let output = '<strong>Fixed Point</strong><br>';
      for (const [key, value] of Object.entries(point)) output += `<strong>${key}:</strong> ${value}<br>`;
      document.getElementById('gmReferenceOutput').innerHTML = output;
    } catch (e) {
      console.error('Error generating fixed point:', e);
      alert('Failed to generate fixed point.');
    }
  }

  function displayTable(tableName) {
    try {
      let output = `<strong>${tableName.replace(/([A-Z])/g, ' $1').trim()}</strong><br>`;
      if (tableName === 'attributeModifiers') {
        const modifiers = [
          { range: '1-2', modifier: '-4' }, { range: '3-4', modifier: '-3' }, { range: '5-6', modifier: '-2' },
          { range: '7-8', modifier: '-1' }, { range: '9-10', modifier: '0' }, { range: '11-12', modifier: '+1' },
          { range: '13-14', modifier: '+2' }, { range: '15-16', modifier: '+3' }, { range: '17-18', modifier: '+4' },
          { range: '19-20', modifier: '+5' }
        ];
        output += '<table><tr><th>Attribute Score</th><th>Modifier</th></tr>';
        modifiers.forEach(m => output += `<tr><td>${m.range}</td><td>${m.modifier}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'combatDCs') {
        const combatDCs = [
          { category: 'Moderate Attack (AC)', value: '15', notes: 'Rift beasts, cultists.' },
          { category: 'Difficult Attack (AC)', value: '20', notes: 'Knights, elites.' },
          { category: 'Basic Melee Damage', value: '1d6 + STR', notes: 'Standard melee.' },
          { category: 'Basic Ranged Damage', value: '1d6 + DEX', notes: 'Standard ranged.' }
        ];
        output += '<table><tr><th>Category</th><th>Value</th><th>Notes</th></tr>';
        combatDCs.forEach(c => output += `<tr><td>${c.category}</td><td>${c.value}</td><td>${c.notes}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'sanityDCs') {
        const sanityDCs = [
          { situation: 'Minor Paradox', dc: '15', notes: 'PL 1/Tier 1 powers.' },
          { situation: 'Major Paradox', dc: '18', notes: 'PL 2/Tier 2 powers.' },
          { situation: 'Hume Collapse', dc: '20', notes: 'Reality unmade.' }
        ];
        output += '<table><tr><th>Situation</th><th>DC</th><th>Notes</th></tr>';
        sanityDCs.forEach(s => output += `<tr><td>${s.situation}</td><td>${s.dc}</td><td>${s.notes}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'paradoxConsequences') {
        const consequences = [
          { failure: 'Minor Failure', consequence: '-2 penalty for 1 encounter.', adjustments: 'Faterunners/Harlequins: -1.' },
          { failure: 'Major Failure', consequence: 'Minor rift (whispers, portal).', adjustments: 'Faterunners/Harlequins: Whispers only.' },
          { failure: 'Epic Failure', consequence: 'Dimensional beast (AC 15, 30 Health).', adjustments: 'Faterunners/Harlequins: AC 14, 20 Health.' }
        ];
        output += '<table><tr><th>Failure Type</th><th>Consequence</th><th>Adjustments</th></tr>';
        consequences.forEach(c => output += `<tr><td>${c.failure}</td><td>${c.consequence}</td><td>${c.adjustments}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'powerCreation') {
        const powerCosts = [
          { pl: 'PL 1', cost: '1', dc: '15', limit: 'None' },
          { pl: 'PL 2', cost: '2', dc: '18', limit: 'None' },
          { pl: 'PL 3', cost: '3', dc: '22', limit: 'Once per session' }
        ];
        output += '<table><tr><th>Power Level</th><th>Fate Point Cost</th><th>DC</th><th>Limit</th></tr>';
        powerCosts.forEach(p => output += `<tr><td>${p.pl}</td><td>${p.cost}</td><td>${p.dc}</td><td>${p.limit}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'levelCaps') {
        const levelCaps = [
          { level: '1-3', fatePoints: '0 (innate)', maxPowers: '0' },
          { level: '4', fatePoints: '4', maxPowers: '4' },
          { level: '5', fatePoints: '5', maxPowers: '5' },
          { level: '15', fatePoints: '15', maxPowers: '15' }
        ];
        output += '<table><tr><th>Level</th><th>Fate Points</th><th>Max Powers</th></tr>';
        levelCaps.forEach(l => output += `<tr><td>${l.level}</td><td>${l.fatePoints}</td><td>${l.maxPowers}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'fatemarkedAbilities') {
        const abilities = [
          { level: '1', ability: 'Fate\'s Edge', effect: 'Advantage on one roll/encounter.', constraint: '1 min focus.', risk: 'INT DC 15, -1 penalty.' },
          { level: '2', ability: 'Fate\'s Influence', effect: 'As above, plus disadvantage on enemy roll.', constraint: '30 ft, visible.', risk: 'INT DC 15, -1 or anomaly.' },
          { level: '3', ability: 'Fate\'s Reach', effect: 'As above, plus any roll.', constraint: 'Dramatic declaration.', risk: 'INT DC 15, -2 or rift.' }
        ];
        output += '<table><tr><th>Level</th><th>Ability</th><th>Effect</th><th>Constraint</th><th>Risk</th></tr>';
        abilities.forEach(a => output += `<tr><td>${a.level}</td><td>${a.ability}</td><td>${a.effect}</td><td>${a.constraint}</td><td>${a.risk}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'challengeRatings') {
        const crs = [
          { type: 'Moderate', cr: 'Party Level', xp: '50/player', stats: 'AC 15, Health 20, Attack +5 (1d6)' },
          { type: 'Hard', cr: 'Party Level +2', xp: '100/player', stats: 'AC 18, Health 40, Attack +7 (1d8)' },
          { type: 'Deadly', cr: 'Party Level +4', xp: '200/player', stats: 'AC 20, Health 60, Attack +9 (2d6)' }
        ];
        output += '<table><tr><th>Type</th><th>Challenge Rating</th><th>XP</th><th>Stats</th></tr>';
        crs.forEach(c => output += `<tr><td>${c.type}</td><td>${c.cr}</td><td>${c.xp}</td><td>${c.stats}</td></tr>`);
        output += '</table>';
      } else if (tableName === 'classResources') {
        const resources = [
          { class: 'Biomatrix Suit', resource: 'Energy Cell (1-hour rest)' },
          { class: 'Continuum Raider', resource: 'Bio-Energy Pool (1-hour rest)' },
          { class: 'Gunrunner', resource: 'Credit Pool (DC 15 check)' },
          { class: 'Warrior', resource: 'Chi Pool (1-hour meditation)' },
          { class: 'Mage', resource: 'Vitality Pool (1-hour rest)' },
          { class: 'Shape', resource: 'Pathos Pool/Darkwell (1-hour ritual)' },
          { class: 'Masque', resource: 'Soulshard Pool (1-hour ritual)' },
          { class: 'Faterunner', resource: 'Fate Points (8-hour rest)' },
          { class: 'Harlequin', resource: 'Fate Points (8-hour rest)' },
          { class: 'Adventurer', resource: 'None' }
        ];
        output += '<table><tr><th>Class</th><th>Resource</th></tr>';
        resources.forEach(r => output += `<tr><td>${r.class}</td><td>${r.resource}</td></tr>`);
        output += '</table>';
      }
      document.getElementById('gmReferenceOutput').innerHTML = output;
    } catch (e) {
      console.error('Error displaying table:', e);
      alert('Failed to display table.');
    }
  }

  function generateCharacterSheet() {
    try {
      const charData = collectCharacterData();
      if (!validateCharacterData(charData)) return;
      const html = generateSheetHTML(charData);
      document.getElementById('sheetPreview').innerHTML = html;
      document.getElementById('sheetText').value = htmlToText(html);
      document.getElementById('sheetModal').style.display = 'flex';
    } catch (e) {
      console.error('Error generating character sheet:', e);
      alert('Failed to generate character sheet.');
    }
  }

  function collectCharacterData() {
    try {
        const lvl = parseInt(document.getElementById('charLevel').value) || 1;
        const cls = document.getElementById('charClass').value || 'Fatemarked';
        const str = parseInt(document.getElementById('attrSTR').value) || 10;
        const dex = parseInt(document.getElementById('attrDEX').value) || 10;
        const con = parseInt(document.getElementById('attrCON').value) || 10;
        const int = parseInt(document.getElementById('attrINT').value) || 10;
        const wis = parseInt(document.getElementById('attrWIS').value) || 10;
        const cha = parseInt(document.getElementById('attrCHA').value) || 10;

        const inherentAbilities = {
            'Biomatrix Suit': '+2 to INT-based checks',
            'Continuum Raider': '+2 to Survival and Navigate checks',
            'Gunrunner': '+2 to Ranged Weapons checks',
            'Faterunner': 'Tier 1 effects have no paradox risk',
            'Harlequin': '+2 to Deception checks',
            'Warrior': '+2 to Melee Weapon checks',
            'Mage': '+2 to Knowledge and Perform checks',
            'Shape': '+2 to Stealth checks',
            'Masque': '+2 to Disguise checks',
            'Adventurer': '+1 skill point per level, reduced cost for cross-class feats',
            'Fatemarked': 'None'
        };

        const skills = [];
        for (let i = 1; i <= skillCounter; i++) {
            const skillSelect = document.getElementById(`skill${i}`);
            const rankInput = document.getElementById(`skillRank${i}`);
            if (skillSelect && skillSelect.value) {
                const skillData = skillsList.find(s => s.name === skillSelect.value);
                const specs = skillData.specs.map(spec => ({
                    name: spec,
                    checked: document.getElementById(`spec${i}_${spec}`)?.checked || false
                }));
                skills.push({
                    name: skillSelect.value,
                    attr: skillData.attr,
                    rank: parseInt(rankInput.value) || 0,
                    specs: specs.filter(s => s.checked).map(s => s.name)
                });
            }
        }

        const feats = [];
        for (let i = 1; i <= startingFeatCounter; i++) {
            const featSelect = document.getElementById(`startingFeat${i}`);
            if (featSelect && featSelect.value !== 'none') {
                feats.push({
                    name: featSelect.value,
                    tier: 1,
                    desc: document.getElementById(`startingFeatDesc${i}`).value || ''
                });
            }
        }
        for (let i = 1; i <= levelUpFeatCounter; i++) {
            const featSelect = document.getElementById(`levelUpFeat${i}`);
            if (featSelect && featSelect.value !== 'none') {
                feats.push({
                    name: featSelect.value,
                    tier: 1,
                    desc: document.getElementById(`levelUpFeatDesc${i}`).value || ''
                });
            }
        }
        for (let i = 1; i <= advantageCounter; i++) {
            const advSelect = document.getElementById(`advantage${i}`);
            if (advSelect && advSelect.value !== 'none') {
                feats.push({
                    name: advSelect.value,
                    tier: parseInt(document.getElementById(`advantageTier${i}`).value) || 1,
                    desc: ''
                });
            }
        }

        const disadvantages = [];
        for (let i = 1; i <= disadvantageCounter; i++) {
            const disSelect = document.getElementById(`disadvantage${i}`);
            if (disSelect && disSelect.value !== 'none') {
                disadvantages.push({
                    name: disSelect.value,
                    tier: parseInt(document.getElementById(`disadvantageTier${i}`).value) || 1
                });
            }
        }

        const powers = [];
        if (lvl <= 3 && cls === 'Fatemarked') {
            // Include Fatemarked abilities only for Levels 1–3
            if (lvl >= 1) powers.push({ 
                name: 'Fate’s Edge', 
                category: 'Manipulation', 
                level: 'PL1', 
                cost: 0, 
                effect: 'Advantage on one roll/encounter', 
                dc: 15, 
                risk: 'INT DC 15, -1 penalty', 
                alignment: 'None' 
            });
            if (lvl >= 2) powers.push({ 
                name: 'Fate’s Influence', 
                category: 'Manipulation', 
                level: 'PL1', 
                cost: 0, 
                effect: 'As above, plus disadvantage on enemy roll', 
                dc: 15, 
                risk: 'INT DC 15, -1 or anomaly', 
                alignment: 'None' 
            });
            if (lvl >= 3) powers.push({ 
                name: 'Fate’s Reach', 
                category: 'Manipulation', 
                level: 'PL1', 
                cost: 0, 
                effect: 'As above, plus any roll', 
                dc: 15, 
                risk: 'INT DC 15, -2 or rift', 
                alignment: 'None' 
            });
        } else if (lvl > 3 && !['Faterunner', 'Harlequin'].includes(cls)) {
            // Collect custom powers for Level 4+ non-Faterunner/Harlequin classes
            for (let i = 1; i <= powerCounter; i++) {
                const nameInput = document.getElementById(`powerName${i}`);
                if (nameInput && nameInput.value) {
                    powers.push({
                        name: nameInput.value,
                        category: document.getElementById(`powerCategory${i}`)?.value || 'none',
                        level: document.getElementById(`powerLevel${i}`).value,
                        cost: parseInt(document.getElementById(`powerCost${i}`).value) || 0,
                        effect: document.getElementById(`powerEffect${i}`).value,
                        dc: parseInt(document.getElementById(`powerDC${i}`).value) || 10,
                        risk: document.getElementById(`powerRisk${i}`).value,
                        alignment: document.getElementById('charAlignment').value
                    });
                }
            }
        }

        const inventory = [];
        for (let i = 1; i <= inventoryCounter; i++) {
            const nameInput = document.getElementById(`itemName${i}`);
            if (nameInput && nameInput.value) {
                inventory.push({
                    name: nameInput.value,
                    slots: parseInt(document.getElementById(`itemSlots${i}`).value) || 0,
                    weight: parseInt(document.getElementById(`itemWeight${i}`).value) || 0,
                    desc: document.getElementById(`itemDesc${i}`).value,
                    durability: document.getElementById(`itemDurability${i}`).value
                });
            }
        }

        const weapons = [];
        for (let i = 1; i <= weaponCounter; i++) {
            const nameInput = document.getElementById(`weaponName${i}`);
            if (nameInput && nameInput.value) {
                weapons.push({
                    name: nameInput.value,
                    damage: document.getElementById(`weaponDamage${i}`).value,
                    range: document.getElementById(`weaponRange${i}`).value,
                    traits: document.getElementById(`weaponTraits${i}`).value,
                    cost: parseInt(document.getElementById(`weaponCost${i}`).value) || 0
                });
            }
        }

        const armors = [];
        for (let i = 1; i <= armorCounter; i++) {
            const nameInput = document.getElementById(`armorName${i}`);
            if (nameInput && nameInput.value) {
                armors.push({
                    name: nameInput.value,
                    ac: parseInt(document.getElementById(`armorAC${i}`).value) || 0,
                    dex: document.getElementById(`armorDEX${i}`).value,
                    str: parseInt(document.getElementById(`armorSTR${i}`).value) || 0,
                    penalties: document.getElementById(`armorPenalties${i}`).value,
                    slots: parseInt(document.getElementById(`armorSlots${i}`).value) || 0,
                    cost: parseInt(document.getElementById(`armorCost${i}`).value) || 0
                });
            }
        }

        const downtime = [];
        for (let i = 1; i <= downtimeCounter; i++) {
            const activityInput = document.getElementById(`downtimeActivity${i}`);
            if (activityInput && activityInput.value) {
                downtime.push({
                    activity: activityInput.value,
                    time: parseInt(document.getElementById(`downtimeTime${i}`).value) || 0,
                    resources: document.getElementById(`downtimeResources${i}`).value,
                    skill: document.getElementById(`downtimeSkill${i}`).value,
                    outcome: document.getElementById(`downtimeOutcome${i}`).value
                });
            }
        }

        const resources = [];
        for (let i = 1; i <= resourceCounter; i++) {
            const nameInput = document.getElementById(`resourceName${i}`);
            if (nameInput && nameInput.value) {
                resources.push({
                    name: nameInput.value,
                    current: parseInt(document.getElementById(`resourceCurrent${i}`).value) || 0,
                    max: parseInt(document.getElementById(`resourceMax${i}`).value) || 0,
                    recharge: document.getElementById(`resourceRecharge${i}`).value
                });
            }
        }

        return {
            name: document.getElementById('charName').value || '',
            player: document.getElementById('playerName').value || '',
            level: lvl,
            class: cls,
            alignment: document.getElementById('charAlignment').value,
            background: document.getElementById('charBackground').value || '',
            appearance: document.getElementById('charAppearance').value || '',
            occupation: document.getElementById('charOccupation').value || '',
            personality: document.getElementById('charPersonality').value || '',
            milestone: document.getElementById('charMilestone').value || '',
            attrMethod: document.getElementById('attrMethod').value,
            attributes: { STR: str, DEX: dex, CON: con, INT: int, WIS: wis, CHA: cha },
            inherentAbility: inherentAbilities[cls],
            skills,
            feats,
            disadvantages,
            powers,
            inventory,
            wealth: {
                credits: parseInt(document.getElementById('credits').value) || 0,
                shards: parseInt(document.getElementById('shards').value) || 0
            },
            weapons,
            armors,
            progression: {
                currentXP: parseInt(document.getElementById('currentXP').value) || 0,
                nextLevelXP: parseInt(document.getElementById('nextLevelXP').value) || getNextLevelXP(lvl)
            },
            lifestyle: {
                type: document.getElementById('charLifestyle').value,
                cost: parseInt(document.getElementById('lifestyleCost').value) || 0
            },
            downtime,
            notes: document.getElementById('charNotes').value || '',
            resources,
            paradoxPoints: parseInt(document.getElementById('paradoxPoints').value) || 0
        };
    } catch (e) {
        console.error('Error collecting character data:', e);
        alert('Failed to collect character data.');
        return {};
    }
}

  function validateCharacterData(data) {
    try {
      if (!data.name) { alert('Character name required!'); return false; }
      if (data.attributes.STR < 8 || data.attributes.STR > 18) { alert('STR out of range (8–18)!'); return false; }
      if (data.attributes.DEX < 8 || data.attributes.DEX > 18) { alert('DEX out of range (8–18)!'); return false; }
      if (data.attributes.CON < 8 || data.attributes.CON > 18) { alert('CON out of range (8–18)!'); return false; }
      if (data.attributes.INT < 8 || data.attributes.INT > 18) { alert('INT out of range (8–18)!'); return false; }
      if (data.attributes.WIS < 8 || data.attributes.WIS > 18) { alert('WIS out of range (8–18)!'); return false; }
      if (data.attributes.CHA < 8 || data.attributes.CHA > 18) { alert('CHA out of range (8–18)!'); return false; }
      if (data.level <= 3 && data.alignment !== 'None') { alert('Alignment must be None for Levels 1–3!'); return false; }
      const maxFeats = data.class === 'Adventurer' ? Math.floor(data.level / 2) + 2 : Math.floor(data.level / 2) + 1;
      const featCount = data.feats.filter(f => !advantagesList.some(a => a.name === f.name)).reduce((sum, f) => {
        if (data.class === 'Adventurer' && !startingFeatsList.some(sf => sf.value === f.name) && 
            !levelUpFeatsList.some(lf => lf.value === f.name && lf.prereq)) return sum + 0.5;
        return sum + 1;
      }, 0);
      if (featCount > maxFeats) { alert(`Too many feats! Max: ${maxFeats}`); return false; }
      let totalAdvantageTiers = 0;
      data.feats.forEach(f => {
        const advantage = advantagesList.find(a => a.name === f.name);
        if (advantage) totalAdvantageTiers += f.tier;
      });
      const totalDisadvantageTiers = data.disadvantages.reduce((s, d) => s + d.tier, 0);
      if (totalAdvantageTiers > totalDisadvantageTiers) { alert(`Advantages (${totalAdvantageTiers} tiers) exceed disadvantages (${totalDisadvantageTiers} tiers)!`); return false; }
      if (data.level > 3 && data.powers.length > data.level) { alert(`Too many powers! Max: ${data.level}`); return false; }
      const totalSlots = data.inventory.reduce((s, i) => s + i.slots, 0) + data.armors.reduce((s, a) => s + a.slots, 0);
      if (totalSlots > 10) { alert('Max 10 inventory slots!'); return false; }
      const totalWeight = data.inventory.reduce((s, i) => s + i.weight, 0);
      if (totalWeight > data.attributes.STR * 10) { alert(`Weight exceeds ${data.attributes.STR * 10} lbs!`); return false; }
      const intMod = getModifier(data.attributes.INT);
      const maxRank = data.level <= 1 ? 4 : 3 + data.level;
      const baseSkillPoints = data.class === 'Adventurer' ? (5 + intMod + 1) : (5 + intMod);
      const skillPoints = data.level === 1 ? baseSkillPoints * 4 : baseSkillPoints * 4 + (2 + intMod + (data.class === 'Adventurer' ? 1 : 0)) * (data.level - 1);
      let usedPoints = data.skills.reduce((s, skill) => s + skill.rank, 0);
      const alignedSkills = {
        'Fatemarked': ['Insight', 'Knowledge'],
        'Biomatrix Suit': ['Technical Expertise', 'Crafting'],
        'Continuum Raider': ['Survival', 'Navigate'],
        'Gunrunner': ['Ranged Weapons'],
        'Faterunner': ['Deception', 'Persuade'],
        'Harlequin': ['Deception', 'Perform'],
        'Warrior': ['Melee Weapon', 'Intimidate'],
        'Mage': ['Knowledge', 'Perform'],
        'Shape': ['Stealth', 'Escape Artist'],
        'Masque': ['Disguise', 'Deception'],
        'Adventurer': ['Knowledge', 'Survival']
      };
      const background = data.background.toLowerCase();
      data.skills.forEach(skill => {
        const skillData = skillsList.find(s => s.name === skill.name);
        const specCost = (skill.name === 'Knowledge' && skill.specs.includes('Arcana') && 
                         (alignedSkills[data.class].includes('Knowledge') || background.includes('arcane'))) ? 1 : 2;
        usedPoints += skill.specs.length * specCost;
      });
      if (usedPoints > skillPoints) { alert(`Skill points exceeded! Available: ${skillPoints}, Used: ${usedPoints}`); return false; }
      if (data.skills.some(skill => skill.rank > maxRank)) { alert(`Skill rank exceeds max (${maxRank})!`); return false; }
      return true;
    } catch (e) {
      console.error('Error validating character data:', e);
      alert('Failed to validate character data.');
      return false;
    }
  }

  function generateSheetHTML(data) {
    try {
        const attrMod = attr => getModifier(data.attributes[attr]);
        const health = data.level === 1 ? 10 + attrMod('CON') : 10 + attrMod('CON') + 5 * (data.level - 1);
        const sanity = data.level === 1 ? 10 + attrMod('WIS') : 10 + attrMod('WIS') + 2 * (data.level - 1);
        const defense = 10 + attrMod('DEX') + data.armors.reduce((s, a) => s + a.ac, 0);
        const resource = {
            'Biomatrix Suit': 'Energy Cell (1-hour rest)',
            'Continuum Raider': 'Bio-Energy Pool (1-hour rest)',
            'Gunrunner': 'Credit Pool (DC 15 check)',
            'Warrior': 'Chi Pool (1-hour meditation)',
            'Mage': 'Vitality Pool (1-hour rest)',
            'Shape': 'Pathos Pool/Darkwell (1-hour ritual)',
            'Masque': 'Soulshard Pool (1-hour ritual)',
            'Faterunner': 'Fate Points (8-hour rest)',
            'Harlequin': 'Fate Points (8-hour rest)',
            'Adventurer': 'None',
            'Fatemarked': 'None'
        }[data.class] || 'None';

        let html = `
            <h2>Continuum Wars Character Sheet</h2>
            <p><strong>Name:</strong> ${data.name} | <strong>Player:</strong> ${data.player}</p>
            <p><strong>Level:</strong> ${data.level} | <strong>Class:</strong> ${data.class} | <strong>Alignment:</strong> ${data.alignment}</p>
            <p><strong>Background:</strong> ${data.background}</p>
            <p><strong>Appearance:</strong> ${data.appearance}</p>
            <p><strong>Occupation:</strong> ${data.occupation}</p>
            <p><strong>Personality & Motivation:</strong> ${data.personality}</p>
            <p><strong>Milestone:</strong> ${data.milestone}</p>
            <p><strong>Inherent Ability:</strong> ${data.inherentAbility}</p>

            <h2>Attributes</h2>
            <table>
                <tr><th>Attribute</th><th>Score</th><th>Modifier</th></tr>
                <tr><td>Strength (STR)</td><td>${data.attributes.STR}</td><td>${attrMod('STR')}</td></tr>
                <tr><td>Dexterity (DEX)</td><td>${data.attributes.DEX}</td><td>${attrMod('DEX')}</td></tr>
                <tr><td>Constitution (CON)</td><td>${data.attributes.CON}</td><td>${attrMod('CON')}</td></tr>
                <tr><td>Intelligence (INT)</td><td>${data.attributes.INT}</td><td>${attrMod('INT')}</td></tr>
                <tr><td>Wisdom (WIS)</td><td>${data.attributes.WIS}</td><td>${attrMod('WIS')}</td></tr>
                <tr><td>Charisma (CHA)</td><td>${data.attributes.CHA}</td><td>${attrMod('CHA')}</td></tr>
            </table>
            <p><strong>Method:</strong> ${data.attrMethod === 'pointBuy' ? 'Point Buy' : 'Random'}</p>

            <h2>Derived Stats</h2>
            <p><strong>Health:</strong> ${health} | <strong>Sanity:</strong> ${sanity} | <strong>Defense:</strong> ${defense}</p>
            <p><strong>Initiative:</strong> ${attrMod('DEX')} | <strong>BAB:</strong> ${getBAB(data.level, data.class)}</p>
            <p><strong>Speed:</strong> 30 ft.</p>
            <p><strong>Saving Throws:</strong> Reflex: +1 + ${attrMod('DEX')} = ${1 + attrMod('DEX')} | Fortitude: +1 + ${attrMod('CON')} = ${1 + attrMod('CON')} | Willpower: +1 + ${attrMod('WIS')} = ${1 + attrMod('WIS')} | Luck: ${data.level >= 4 ? attrMod('CHA') + 2 : 0}</p>
            <p><strong>Fate Points:</strong> ${data.level <= 3 ? 0 : data.level} | <strong>Paradox Points:</strong> ${data.paradoxPoints}</p>

            <h2>Resources</h2>
            <table>
                <tr><th>Name</th><th>Current</th><th>Max</th><th>Recharge</th></tr>
                ${data.resources.map(r => `
                    <tr>
                        <td>${r.name}</td>
                        <td>${r.current}</td>
                        <td>${r.max}</td>
                        <td>${r.recharge}</td>
                    </tr>
                `).join('')}
            </table>

            <h2>Skills</h2>
            <table>
                <tr><th>Skill</th><th>Attribute</th><th>Rank</th><th>Specializations</th><th>Total Bonus</th></tr>
                ${data.skills.map(s => `
                    <tr>
                        <td>${s.name}</td>
                        <td>${s.attr}</td>
                        <td>${s.rank}</td>
                        <td>${s.specs.join(', ') || 'None'}</td>
                        <td>${s.rank + attrMod(s.attr.split('/')[0]) + (s.specs.length ? 2 : 0)}</td>
                    </tr>
                `).join('')}
            </table>

            <h2>Feats & Advantages</h2>
            <table>
                <tr><th>Name</th><th>Tier</th><th>Description</th></tr>
                ${data.feats.map(f => `
                    <tr>
                        <td>${f.name}</td>
                        <td>${f.tier}</td>
                        <td>${f.desc || (startingFeatsList.find(fe => fe.value === f.name)?.text || levelUpFeatsList.find(fe => fe.value === f.name)?.text || advantagesList.find(a => a.name === f.name)?.desc)}</td>
                    </tr>
                `).join('')}
            </table>

            <h2>Disadvantages</h2>
            <table>
                <tr><th>Name</th><th>Tier</th><th>Description</th></tr>
                ${data.disadvantages.map(d => `
                    <tr>
                        <td>${d.name}</td>
                        <td>${d.tier}</td>
                        <td>${disadvantagesList.find(dis => dis.name === d.name)?.desc}</td>
                    </tr>
                `).join('')}
            </table>

            <h2>Powers/Effects</h2>
            <table>
                <tr><th>Name</th><th>Category</th><th>Level</th><th>Cost</th><th>Effect</th><th>DC</th><th>Paradox Risk</th><th>Alignment</th></tr>
                ${data.powers.map(p => `
                    <tr>
                        <td>${p.name}</td>
                        <td>${p.category}</td>
                        <td>${p.level}</td>
                        <td>${p.cost}</td>
                        <td>${p.effect}</td>
                        <td>${p.dc}</td>
                        <td>${p.risk}</td>
                        <td>${p.alignment}</td>
                    </tr>
                `).join('')}
            </table>
            <p><strong>Resource:</strong> ${resource}</p>

            <h2>Inventory</h2>
            <table>
                <tr><th>Item</th><th>Slots</th><th>Weight</th><th>Description</th><th>Durability</th></tr>
                ${data.inventory.map(i => `
                    <tr>
                        <td>${i.name}</td>
                        <td>${i.slots}</td>
                        <td>${i.weight}</td>
                        <td>${i.desc}</td>
                        <td>${i.durability}</td>
                    </tr>
                `).join('')}
            </table>
            <p><strong>Carrying Capacity:</strong> Normal: ${data.attributes.STR * 10} lbs | Heavy: ${data.attributes.STR * 20} lbs</p>
            <p><strong>Wealth:</strong> Credits: ${data.wealth.credits} | Rift Shards: ${data.wealth.shards}</p>

            <h2>Combat</h2>
            <p><strong>Melee Attack:</strong> d20 + ${getBAB(data.level, data.class)} + ${attrMod('STR')} + Melee Weapon Rank</p>
            <p><strong>Ranged Attack:</strong> d20 + ${getBAB(data.level, data.class)} + ${attrMod('DEX')} + Ranged Weapons Rank</p>
            <table>
                <tr><th>Weapon</th><th>Damage</th><th>Range</th><th>Traits</th><th>Cost</th></tr>
                ${data.weapons.map(w => `
                    <tr>
                        <td>${w.name}</td>
                        <td>${w.damage}</td>
                        <td>${w.range}</td>
                        <td>${w.traits}</td>
                        <td>${w.cost}</td>
                    </tr>
                `).join('')}
            </table>
            <table>
                <tr><th>Armor</th><th>AC</th><th>Max DEX</th><th>STR Req</th><th>Penalties</th><th>Slots</th><th>Cost</th></tr>
                ${data.armors.map(a => `
                    <tr>
                        <td>${a.name}</td>
                        <td>${a.ac}</td>
                        <td>${a.dex}</td>
                        <td>${a.str}</td>
                        <td>${a.penalties}</td>
                        <td>${a.slots}</td>
                        <td>${a.cost}</td>
                    </tr>
                `).join('')}
            </table>

            <h2>Progression</h2>
            <p><strong>XP:</strong> ${data.progression.currentXP} / ${data.progression.nextLevelXP}</p>
            <p><strong>Next Level Benefits:</strong> +1 Attribute (every 3 levels), +5 Health, +2 Sanity, ${2 + attrMod('INT') + (data.class === 'Adventurer' ? 1 : 0)} Skill Points, Feat at even levels</p>

            <h2>Lifestyle</h2>
            <p><strong>Type:</strong> ${data.lifestyle.type} | <strong>Cost:</strong> ${data.lifestyle.cost} Credits/day</p>

            <h2>Downtime Activities</h2>
            <table>
                <tr><th>Activity</th><th>Time</th><th>Resources</th><th>Skill Check</th><th>Outcome</th></tr>
                ${data.downtime.map(d => `
                    <tr>
                        <td>${d.activity}</td>
                        <td>${d.time} days</td>
                        <td>${d.resources}</td>
                        <td>${d.skill}</td>
                        <td>${d.outcome}</td>
                    </tr>
                `).join('')}
            </table>

            <h2>Notes</h2>
            <p>${data.notes.replace(/\n/g, '<br>')}</p>
        `;
        return html;
    } catch (e) {
        console.error('Error generating sheet HTML:', e);
        alert('Failed to generate sheet HTML.');
        return '';
    }
}

  function htmlToText(html) {
    try {
      const div = document.createElement('div');
      div.innerHTML = html;
      return div.innerText.replace(/\n+/g, '\n').trim();
    } catch (e) {
      console.error('Error converting HTML to text:', e);
      return '';
    }
  }

  function exportToPDF() {
    try {
        const charData = collectCharacterData();
        if (!validateCharacterData(charData)) {
            alert('Invalid character data. Please check inputs.');
            return;
        }
        const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });
        const margin = 10;
        const contentWidth = 190;
        let yPos = margin;
        const lineHeight = 6;
        const colWidth = contentWidth / 5;
        let pageNumber = 1;

        const addText = (text, options = {}) => {
            pdf.setFontSize(options.fontSize || 10);
            pdf.setFont('helvetica', options.bold ? 'bold' : 'normal');
            const indent = options.indent || 0;
            const align = options.align || 'left';
            const lines = pdf.splitTextToSize(text, contentWidth - indent);
            let xPos = margin + indent;
            lines.forEach(line => {
                if (yPos + lineHeight > 287) {
                    addHeaderFooter();
                    pdf.addPage();
                    yPos = margin;
                    pageNumber++;
                }
                if (align === 'center') {
                    const textWidth = pdf.getTextWidth(line);
                    xPos = margin + (contentWidth - textWidth) / 2;
                }
                pdf.text(line, xPos, yPos);
                yPos += lineHeight;
            });
            if (options.underline) {
                pdf.setLineWidth(0.2);
                pdf.line(margin, yPos - 3, margin + contentWidth, yPos - 3);
                yPos += 2;
            }
            return yPos;
        };

        const addTable = (header, rows, colWidths) => {
            const rowHeight = lineHeight * 1.2;
            const tableHeight = rowHeight * (rows.length + 1);
            if (yPos + tableHeight > 287) {
                addHeaderFooter();
                pdf.addPage();
                yPos = margin;
                pageNumber++;
            }
            const startY = yPos;
            pdf.setFillColor(245, 245, 245);
            pdf.rect(margin, yPos - rowHeight, contentWidth, tableHeight, 'F');
            pdf.setFontSize(9);
            pdf.setFont('helvetica', 'bold');
            pdf.setFillColor(208, 208, 208);
            pdf.rect(margin, yPos - rowHeight, contentWidth, rowHeight, 'F');
            header.forEach((col, i) => {
                pdf.text(col, margin + colWidths.slice(0, i).reduce((a, b) => a + b, 0) + 2, yPos - 2);
            });
            yPos += rowHeight;
            pdf.setFont('helvetica', 'normal');
            rows.forEach((row, rowIndex) => {
                if (yPos + rowHeight > 287) {
                    addHeaderFooter();
                    pdf.addPage();
                    yPos = margin;
                    pageNumber++;
                }
                if (rowIndex % 2 === 1) {
                    pdf.setFillColor(230, 230, 230);
                    pdf.rect(margin, yPos - rowHeight, contentWidth, rowHeight, 'F');
                }
                row.forEach((col, i) => {
                    const text = String(col).substring(0, Math.floor(colWidths[i] / 2));
                    pdf.text(text, margin + colWidths.slice(0, i).reduce((a, b) => a + b, 0) + 2, yPos - 2);
                });
                yPos += rowHeight;
            });
            pdf.setLineWidth(0.1);
            pdf.setDrawColor(51, 51, 51);
            pdf.rect(margin, startY - rowHeight, contentWidth, tableHeight);
            for (let i = 1; i <= rows.length; i++) {
                pdf.line(margin, startY + rowHeight * i - rowHeight, margin + contentWidth, startY + rowHeight * i - rowHeight);
            }
            let xPos = margin;
            colWidths.forEach(w => {
                pdf.line(xPos, startY - rowHeight, xPos, yPos - rowHeight);
                xPos += w;
            });
            pdf.line(xPos, startY - rowHeight, xPos, yPos - rowHeight);
            yPos += 2;
            return yPos;
        };

        const addHeaderFooter = () => {
            pdf.setFontSize(8);
            pdf.setFont('helvetica', 'italic');
            pdf.setTextColor(100, 100, 100);
            pdf.text(`Character: ${charData.name || 'Unknown'}`, margin, 293);
            pdf.text(`Page ${pageNumber}`, 200 - margin, 293, { align: 'right' });
            pdf.setTextColor(0, 0, 0);
            pdf.setFont('helvetica', 'normal');
        };

        yPos = addText('Continuum Wars Character Sheet', { fontSize: 14, bold: true, underline: true });
        yPos += lineHeight;
        yPos = addText(`Name: ${charData.name} | Player: ${charData.player}`);
        yPos = addText(`Level: ${charData.level} | Class: ${charData.class} | Alignment: ${charData.alignment}`);
        yPos = addText(`Background: ${charData.background}`);
        yPos = addText(`Appearance: ${charData.appearance}`);
        yPos = addText(`Occupation: ${charData.occupation}`);
        yPos = addText(`Personality & Motivation: ${charData.personality}`);
        yPos = addText(`Milestone: ${charData.milestone}`);
        yPos = addTable(
            ['Attribute', 'Score', 'Modifier'],
            ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'].map(attr => [
                attr,
                charData.attributes[attr],
                getModifier(charData.attributes[attr])
            ]),
            [colWidth, colWidth, colWidth]
        );
        const conMod = getModifier(charData.attributes.CON);
        const dexMod = getModifier(charData.attributes.DEX);
        const wisMod = getModifier(charData.attributes.WIS);
        const chaMod = getModifier(charData.attributes.CHA);
        const health = charData.level === 1 ? 10 + conMod : 10 + conMod + 5 * (charData.level - 1);
        const sanity = charData.level === 1 ? 10 + wisMod : 10 + wisMod + 2 * (charData.level - 1);
        const defense = 10 + dexMod + charData.armors.reduce((s, a) => s + a.ac, 0);
        yPos = addText(`Health: ${health} | Sanity: ${sanity} | Defense: ${defense}`);
        yPos = addText(`Initiative: ${dexMod} | BAB: ${getBAB(charData.level, charData.class)}`);
        yPos = addText(`Speed: 30 ft.`);
        yPos = addText(`Saving Throws: Reflex: +1 + ${dexMod} = ${1 + dexMod} | Fortitude: +1 + ${conMod} = ${1 + conMod} | Willpower: +1 + ${wisMod} = ${1 + wisMod} | Luck: ${charData.level >= 4 ? chaMod + 2 : 0}`);
        yPos = addText(`Fate Points: ${charData.level <= 3 ? 0 : charData.level} | Paradox Points: ${charData.paradoxPoints}`);
        yPos += lineHeight * 1.5;

        yPos = addText('Resources', { fontSize: 14, bold: true, underline: true });
        yPos = addTable(
            ['Name', 'Current', 'Max', 'Recharge'],
            charData.resources.map(r => [r.name, r.current, r.max, r.recharge]),
            [colWidth, colWidth / 2, colWidth / 2, colWidth]
        );
        yPos = addTable(
            ['Skill', 'Attribute', 'Rank', 'Specializations', 'Total Bonus'],
            charData.skills.map(s => [
                s.name,
                s.attr,
                s.rank,
                s.specs.join(', ') || 'None',
                s.rank + getModifier(charData.attributes[s.attr.split('/')[0]]) + (s.specs.length ? 2 : 0)
            ]),
            [colWidth, colWidth, colWidth / 2, colWidth, colWidth / 2]
        );
        yPos += lineHeight;

        yPos = addText('Feats & Advantages', { fontSize: 14, bold: true, underline: true });
        yPos = addTable(
            ['Name', 'Tier', 'Description'],
            charData.feats.map(f => [
                f.name,
                f.tier,
                (f.desc || startingFeatsList.find(fe => fe.value === f.name)?.text || 
                 levelUpFeatsList.find(fe => fe.value === f.name)?.text || 
                 advantagesList.find(a => a.name === f.name)?.desc || '').substring(0, 50)
            ]),
            [colWidth, colWidth / 2, colWidth * 2.5]
        );
        yPos += lineHeight;

        yPos = addText('Disadvantages', { fontSize: 14, bold: true, underline: true });
        yPos = addTable(
            ['Name', 'Tier', 'Description'],
            charData.disadvantages.map(d => [
                d.name,
                d.tier,
                (disadvantagesList.find(dis => dis.name === d.name)?.desc || '').substring(0, 50)
            ]),
            [colWidth, colWidth / 2, colWidth * 2.5]
        );
        yPos += lineHeight;

        yPos = addText('Powers/Effects', { fontSize: 14, bold: true, underline: true });
        yPos = addTable(
            ['Name', 'Category', 'Level', 'Cost', 'Effect', 'DC', 'Paradox Risk'],
            charData.powers.map(p => [
                p.name,
                p.category,
                p.level,
                p.cost,
                (p.effect || '').substring(0, 30),
                p.dc,
                (p.risk || '').substring(0, 30)
            ]),
            [colWidth, colWidth / 2, colWidth / 2, colWidth / 2, colWidth * 1.5, colWidth / 2, colWidth]
        );
        yPos = addText(`Resource: ${{
            'Biomatrix Suit': 'Energy Cell (1-hour rest)',
            'Continuum Raider': 'Bio-Energy Pool (1-hour rest)',
            'Gunrunner': 'Credit Pool (DC 15 check)',
            'Warrior': 'Chi Pool (1-hour meditation)',
            'Mage': 'Vitality Pool (1-hour rest)',
            'Shape': 'Pathos Pool/Darkwell (1-hour ritual)',
            'Masque': 'Soulshard Pool (1-hour ritual)',
            'Faterunner': 'Fate Points (8-hour rest)',
            'Harlequin': 'Fate Points (8-hour rest)',
            'Adventurer': 'None',
            'Fatemarked': 'None'
        }[charData.class] || 'None'}`);
        yPos += lineHeight * 1.5;

        yPos = addText('Inventory', { fontSize: 14, bold: true, underline: true });
        yPos = addTable(
            ['Item', 'Slots', 'Weight', 'Description', 'Durability'],
            charData.inventory.map(i => [
                i.name,
                i.slots,
                i.weight,
                (i.desc || '').substring(0, 30),
                i.durability
            ]),
            [colWidth, colWidth / 2, colWidth / 2, colWidth, colWidth]
        );
        yPos = addText(`Carrying Capacity: Normal: ${charData.attributes.STR * 10} lbs | Heavy: ${charData.attributes.STR * 20} lbs`);
        yPos = addText(`Melee Attack: d20 + ${getBAB(charData.level, charData.class)} + ${getModifier(charData.attributes.STR)} + Melee Weapon Rank`);
        yPos = addText(`Ranged Attack: d20 + ${getBAB(charData.level, charData.class)} + ${getModifier(charData.attributes.DEX)} + Ranged Weapons Rank`);

        yPos = addText('Combat', { fontSize: 14, bold: true, underline: true });
        yPos = addText(`Melee Attack: d20 + ${getBAB(charData.level, charData.class)} + ${Math.floor((charData.attributes.STR - 10) / 2)} + Melee Weapon Rank`);
        yPos = addText(`Ranged Attack: d20 + ${getBAB(charData.level, charData.class)} + ${Math.floor((charData.attributes.DEX - 10) / 2)} + Ranged Weapons Rank`);
        yPos += lineHeight;
        yPos = addTable(
            ['Weapon', 'Damage', 'Range', 'Traits', 'Cost'],
            charData.weapons.map(w => [
                w.name,
                w.damage,
                w.range,
                (w.traits || '').substring(0, 30),
                w.cost
            ]),
            [colWidth, colWidth, colWidth, colWidth, colWidth / 2]
        );
        yPos = addTable(
            ['Armor', 'AC', 'Max DEX', 'STR Req', 'Penalties', 'Slots', 'Cost'],
            charData.armors.map(a => [
                a.name,
                a.ac,
                a.dex,
                a.str,
                (a.penalties || '').substring(0, 30),
                a.slots,
                a.cost
            ]),
            [colWidth, colWidth / 2, colWidth / 2, colWidth / 2, colWidth, colWidth / 2, colWidth / 2]
        );
        yPos = addText(`Next Level Benefits: +1 Attribute (every 3 levels), +5 Health, +2 Sanity, ${2 + getModifier(charData.attributes.INT) + (charData.class === 'Adventurer' ? 1 : 0)} Skill Points, Feat at even levels`);

        yPos = addText('Progression', { fontSize: 14, bold: true, underline: true });
        yPos = addText(`XP: ${charData.progression.currentXP} / ${charData.progression.nextLevelXP}`);
        yPos = addText(`Next Level Benefits: +1 Attribute (every 3 levels), +5 Health, +2 Sanity, ${2 + Math.floor((charData.attributes.INT - 10) / 2) + (charData.class === 'Adventurer' ? 1 : 0)} Skill Points, Feat at even levels`);
        yPos += lineHeight;

        yPos = addText('Lifestyle', { fontSize: 14, bold: true, underline: true });
        yPos = addText(`Type: ${charData.lifestyle.type} | Cost: ${charData.lifestyle.cost} Credits/day`);
        yPos += lineHeight * 1.5;

        yPos = addText('Downtime Activities', { fontSize: 14, bold: true, underline: true });
        yPos = addTable(
            ['Activity', 'Time', 'Resources', 'Skill Check', 'Outcome'],
            charData.downtime.map(d => [
                d.activity,
                `${d.time} days`,
                (d.resources || '').substring(0, 30),
                d.skill,
                (d.outcome || '').substring(0, 30)
            ]),
            [colWidth, colWidth / 2, colWidth, colWidth, colWidth]
        );
        yPos += lineHeight;

        yPos = addText('Notes', { fontSize: 14, bold: true, underline: true });
        yPos = addText(charData.notes.replace(/\n/g, '; '));
        yPos += lineHeight;

        addHeaderFooter();
        pdf.save(`${charData.name || 'Character'}_Sheet.pdf`);
    } catch (e) {
        console.error('Error exporting to PDF:', e);
        alert('Failed to export to PDF.');
    }
}

  function copySheetText() {
    try {
      const textArea = document.getElementById('sheetText');
      if (navigator.clipboard && textArea) {
        navigator.clipboard.writeText(textArea.value)
          .then(() => {
            alert('Sheet text copied to clipboard!');
          })
          .catch(err => {
            console.error('Clipboard write failed:', err);
            alert('Failed to copy sheet text.');
          });
      } else if (textArea) {
        textArea.select();
        document.execCommand('copy');
        alert('Sheet text copied to clipboard!');
      } else {
        alert('Sheet text area not found.');
      }
    } catch (e) {
      console.error('Error copying sheet text:', e);
      alert('Failed to copy sheet text.');
    }
  }

  function saveCharacter() {
    try {
      const charData = collectCharacterData();
      if (!validateCharacterData(charData)) return;
      const json = JSON.stringify(charData);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${charData.name || 'Character'}.json`;
      a.click();
      URL.revokeObjectURL(url);
      localStorage.setItem(`character_${charData.name}`, json);
      alert('Character saved!');
    } catch (e) {
      console.error('Error saving character:', e);
      alert('Failed to save character.');
    }
  }

  function loadCharacter(event) {
    try {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const charData = JSON.parse(e.target.result);
        populateCharacterSheet(charData);
        alert('Character loaded!');
      };
      reader.readAsText(file);
    } catch (e) {
      console.error('Error loading character:', e);
      alert('Failed to load character.');
    }
  }

  function populateCharacterSheet(data) {
    try {
      if (!data || !data.name) {
        throw new Error('Invalid character data.');
      }
      console.log('Populating character sheet with data:', JSON.stringify(data, null, 2));
      window.isLoadingCharacter = true;

      // Helper to set input values
      const setValue = (id, value) => {
        const el = document.getElementById(id);
        if (el) {
          const oldValue = el.value;
          el.value = value !== undefined && value !== null ? value : '';
          console.log(`Set ${id} from ${oldValue} to ${el.value} (intended: ${value})`);
        } else {
          console.warn(`Element ${id} not found`);
        }
      };

      // Clear dynamic fields
      const containers = [
        'skillsContainer', 'startingFeatsContainer', 'levelUpFeatsContainer',
        'advantagesContainer', 'disadvantagesContainer', 'powersContainer',
        'inventoryContainer', 'weaponsContainer', 'armorContainer',
        'downtimeContainer', 'resourcesContainer'
      ];
      containers.forEach(container => {
        const el = document.getElementById(container);
        if (el) el.innerHTML = '';
      });
      skillCounter = startingFeatCounter = levelUpFeatCounter = advantageCounter =
      disadvantageCounter = powerCounter = inventoryCounter = weaponCounter =
      armorCounter = downtimeCounter = resourceCounter = 0;
      rolledStats = [];
      assignedStats = {};
      availableStats = [];
      skillCriticalTracker = {};
      fatePointsUsedInEncounter = 0;

      // Step 1: Set class and level
      const level = data.level || 1;
      let charClass = data.class || 'Fatemarked';
      if (level > 3 && charClass === 'Fatemarked') {
        console.warn('Fatemarked invalid at level > 3, defaulting to Continuum Raider');
        charClass = 'Continuum Raider';
      }
      const classSelect = document.getElementById('charClass');
      if (classSelect) {
        const advancedClasses = [
          'Fatemarked', 'Biomatrix Suit', 'Continuum Raider', 'Gunrunner', 'Faterunner', 'Harlequin',
          'Warrior', 'Mage', 'Shape', 'Masque', 'Adventurer'
        ];
        classSelect.innerHTML = level <= 3 ? '<option value="Fatemarked">Fatemarked</option>' :
          advancedClasses.map(cls => `<option value="${cls}">${cls}</option>`).join('');
        const classOptions = Array.from(classSelect.options).map(opt => opt.value);
        setValue('charClass', classOptions.includes(charClass) ? charClass : 'Continuum Raider');
      }
      setValue('charLevel', level);
      setValue('charAlignment', data.alignment || (level <= 3 ? 'None' : 'Balance'));

      // Step 2: Set attrMethod and attributes
      setValue('attrMethod', 'imported');
      ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'].forEach(attr => {
        const value = data.attributes && data.attributes[attr] && data.attributes[attr] >= 8 && data.attributes[attr] <= 18 ? data.attributes[attr] : 10;
        setValue(`attr${attr}`, value);
        const input = document.getElementById(`attr${attr}`);
        if (input) input.readOnly = true;
        const assignSelect = document.getElementById(`assign${attr}`);
        if (assignSelect) {
          assignSelect.classList.add('hidden');
          assignSelect.value = '';
          assignSelect.disabled = true;
        }
      });
      setValue('pointsRemaining', 'N/A');
      document.getElementById('rerollButton')?.classList.add('hidden');
      document.getElementById('randomRolls')?.classList.add('hidden');
      document.getElementById('confirmAssignments')?.classList.add('hidden');

      // Step 3: Load basic info
      setValue('charName', data.name);
      setValue('playerName', data.player);
      setValue('charBackground', data.background);
      setValue('charAppearance', data.appearance);
      setValue('charOccupation', data.occupation);
      setValue('charPersonality', data.personality);
      setValue('charMilestone', data.milestone);
      setValue('charNotes', data.notes);
      setValue('credits', data.wealth?.credits || 0);
      setValue('shards', data.wealth?.shards || 0);
      setValue('currentXP', data.progression?.currentXP || 0);
      setValue('nextLevelXP', data.progression?.nextLevelXP || getNextLevelXP(level));
      setValue('charLifestyle', data.lifestyle?.type || 'Squalid');
      setValue('lifestyleCost', data.lifestyle?.cost || 0);
      setValue('paradoxPoints', data.paradoxPoints || 0);
      setValue('fatePointsCurrent', level <= 3 ? 0 : level);

      // Step 4: Load disadvantages
      if (data.disadvantages) {
        data.disadvantages.forEach(dis => {
          addDisadvantageField();
          const i = disadvantageCounter;
          setValue(`disadvantage${i}`, dis.name);
          setValue(`disadvantageTier${i}`, dis.tier || 1);
        });
      }

      // Step 5: Load feats and advantages
      if (data.feats) {
        data.feats.forEach(feat => {
          if (startingFeatsList.some(f => f.value === feat.name)) {
            addStartingFeatField();
            const i = startingFeatCounter;
            setValue(`startingFeat${i}`, feat.name);
            if (feat.name === 'custom') setValue(`startingFeatDesc${i}`, feat.desc);
          } else if (levelUpFeatsList.some(f => f.value === feat.name) || feat.name === 'custom') {
            addLevelUpFeatField();
            const i = levelUpFeatCounter;
            setValue(`levelUpFeat${i}`, feat.name);
            if (feat.name === 'custom') setValue(`levelUpFeatDesc${i}`, feat.desc);
          } else if (advantagesList.some(a => a.name === feat.name)) {
            addAdvantageField();
            const i = advantageCounter;
            setValue(`advantage${i}`, feat.name);
            setValue(`advantageTier${i}`, feat.tier || 1);
          }
        });
      }

      // Step 6: Load powers
      if (data.powers && level > 3 && !['Faterunner', 'Harlequin'].includes(charClass)) {
        powerCounter = 0;
        data.powers.forEach(power => {
          addPowerField();
          const i = powerCounter;
          setValue(`powerCategory${i}`, power.category || 'none');
          setValue(`powerName${i}`, power.name);
          setValue(`powerLevel${i}`, power.level);
          setValue(`powerCost${i}`, power.cost || 0);
          setValue(`powerEffect${i}`, power.effect);
          setValue(`powerDC${i}`, power.dc || 10);
          setValue(`powerRisk${i}`, power.risk);
        });
      }

      // Step 7: Load skills
      if (data.skills) {
        data.skills.forEach(skill => {
          addSkillField();
          const i = skillCounter;
          setValue(`skill${i}`, skill.name);
          setValue(`skillRank${i}`, skill.rank || 0);
          updateSkillSpecs(i);
          skill.specs.forEach(spec => {
            const specCheckbox = document.getElementById(`spec${i}_${spec}`);
            if (specCheckbox) specCheckbox.checked = true;
          });
        });
      }

      // Step 8: Load inventory
      if (data.inventory) {
        data.inventory.forEach(item => {
          addInventoryField();
          const i = inventoryCounter;
          setValue(`itemName${i}`, item.name);
          setValue(`itemSlots${i}`, item.slots || 0);
          setValue(`itemWeight${i}`, item.weight || 0);
          setValue(`itemDesc${i}`, item.desc);
          setValue(`itemDurability${i}`, item.durability);
        });
      }

      // Step 9: Load weapons
      if (data.weapons) {
        data.weapons.forEach(weapon => {
          addWeaponField();
          const i = weaponCounter;
          setValue(`weaponName${i}`, weapon.name);
          setValue(`weaponDamage${i}`, weapon.damage);
          setValue(`weaponRange${i}`, weapon.range);
          setValue(`weaponTraits${i}`, weapon.traits);
          setValue(`weaponCost${i}`, weapon.cost || 0);
        });
      }

      // Step 10: Load armor
      if (data.armors) {
        data.armors.forEach(armor => {
          addArmorField();
          const i = armorCounter;
          setValue(`armorName${i}`, armor.name);
          setValue(`armorAC${i}`, armor.ac || 0);
          setValue(`armorDEX${i}`, armor.dex);
          setValue(`armorSTR${i}`, armor.str || 0);
          setValue(`armorPenalties${i}`, armor.penalties);
          setValue(`armorSlots${i}`, armor.slots || 0);
          setValue(`armorCost${i}`, armor.cost || 0);
        });
      }

      // Step 11: Load downtime
      if (data.downtime) {
        data.downtime.forEach(activity => {
          addDowntimeField();
          const i = downtimeCounter;
          setValue(`downtimeActivity${i}`, activity.activity);
          setValue(`downtimeTime${i}`, activity.time || 0);
          setValue(`downtimeResources${i}`, activity.resources);
          setValue(`downtimeSkill${i}`, activity.skill);
          setValue(`downtimeOutcome${i}`, activity.outcome);
          updateDowntimeOutcome(i);
        });
      }

      // Step 12: Load resources
      if (data.resources) {
        data.resources.forEach(resource => {
          addResourceField();
          const i = resourceCounter;
          setValue(`resourceName${i}`, resource.name);
          setValue(`resourceCurrent${i}`, resource.current || 0);
          setValue(`resourceMax${i}`, resource.max || 0);
          setValue(`resourceRecharge${i}`, resource.recharge);
        });
      }

      // Step 13: Finalize updates
      updateSheetInputs({ skipPowers: false, preserveAttributes: true });
      updateSkills();
      debouncedUpdateFeatsSheet();
      updateInputs();
      updateSkillSpecOptions();
      updateFeats();
      updateClassAbilities();
      console.log(`Final DOM state: class=${document.getElementById('charClass')?.value}, BAB=${document.getElementById('charBAB')?.value}`);
      window.isLoadingCharacter = false;
    } catch (e) {
      console.error('Error populating character sheet:', e);
      alert(`Failed to populate character sheet: ${e.message}`);
      window.isLoadingCharacter = false;
    }
  }

  function generateCharacterSheet() {
    try {
      const charData = collectCharacterData();
      if (!validateCharacterData(charData)) return;
      const html = generateSheetHTML(charData);
      document.getElementById('sheetPreview').innerHTML = html;
      document.getElementById('sheetText').value = htmlToText(html);
      document.getElementById('sheetModal').style.display = 'flex';
    } catch (e) {
      console.error('Error generating character sheet:', e);
      alert('Failed to generate character sheet.');
    }
  }

    function closeModal() {
      try {
        document.getElementById('sheetModal').style.display = 'none';
      } catch (e) {
        console.error('Error closing modal:', e);
        alert('Failed to close modal.');
      }
    }
  
  /**
   * Clears all character sheet fields and resets the form to its default state.
   * This function is the single source of truth for clearing the sheet.
   */
  function clearSheetFields() {
    try {
      // Reset select fields to defaults
      const charAlignmentEl = document.getElementById('charAlignment');
      if (charAlignmentEl) charAlignmentEl.value = 'None';
      const attrMethodEl = document.getElementById('attrMethod');
      if (attrMethodEl) attrMethodEl.value = 'pointBuy';
      const charLifestyleEl = document.getElementById('charLifestyle');
      if (charLifestyleEl) charLifestyleEl.value = 'Squalid';
  
      // Clear dynamic containers
      [
        'skillsContainer', 'startingFeatsContainer', 'levelUpFeatsContainer', 'advantagesContainer',
        'disadvantagesContainer', 'powersContainer', 'inventoryContainer', 'weaponsContainer',
        'armorContainer', 'downtimeContainer', 'resourcesContainer'
      ].forEach(container => {
        const el = document.getElementById(container);
        if (el) el.innerHTML = '';
      });
  
      // Reset counters and trackers
      skillCounter = startingFeatCounter = levelUpFeatCounter = advantageCounter = disadvantageCounter =
      powerCounter = inventoryCounter = weaponCounter = armorCounter = downtimeCounter = resourceCounter = 0;
      const charClassEl = document.getElementById('charClass');
      if (charClassEl) charClassEl.value = 'Fatemarked';
      availableStats = [];
      skillCriticalTracker = {};
      fatePointsUsedInEncounter = 0;
  
      // Update UI and state
      updateSheetInputs({ preserveAttributes: true });
      debouncedUpdateFeatsSheet();
      alert('Character sheet cleared!');
    } catch (e) {
      console.error('Error clearing sheet fields:', e);
      alert('Failed to clear sheet fields.');
    }
  }
  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    try {
      // Clear power fields
      const powersContainer = document.getElementById('powersContainer');
      if (powersContainer) {
        powersContainer.innerHTML = '';
        powerCounter = 0;
        console.log('Cleared powersContainer and reset powerCounter');
      }

      // Initialize character sheet
      updateSheetInputs({ skipPowers: true, preserveAttributes: true });
      debouncedUpdateFeatsSheet();

      // Initialize roll tool
      updateInputs();
      updateSkillSpecOptions();
      updateFeats();
      updateClassAbilities();

      // Add dynamic onchange handlers
      const inputs = [
        { id: 'charName', handler: () => {
          console.log('charName changed to:', document.getElementById('charName').value);
          updateInputs();
          updateSkillSpecOptions();
          updateFeats();
          updateClassAbilities();
        }},
        { id: 'charLevel', handler: () => {
          console.log('charLevel changed to:', document.getElementById('charLevel').value);
          updateSheetInputs({ preserveAttributes: true });
          updateInputs();
          updateSkillSpecOptions();
          updateFeats();
          updateClassAbilities();
        }},
        { id: 'charClass', handler: () => {
          console.log('charClass changed to:', document.getElementById('charClass').value);
          updateSheetInputs({ preserveAttributes: true });
          updateInputs();
          updateSkillSpecOptions();
          updateFeats();
          updateClassAbilities();
        }},
        { id: 'attrSTR', handler: () => updateSheetInputs({ preserveAttributes: true }) },
        { id: 'attrDEX', handler: () => updateSheetInputs({ preserveAttributes: true }) },
        { id: 'attrCON', handler: () => updateSheetInputs({ preserveAttributes: true }) },
        { id: 'attrINT', handler: () => updateSheetInputs({ preserveAttributes: true }) },
        { id: 'attrWIS', handler: () => updateSheetInputs({ preserveAttributes: true }) },
        { id: 'attrCHA', handler: () => updateSheetInputs({ preserveAttributes: true }) }
      ];
      inputs.forEach(({ id, handler }) => {
        const input = document.getElementById(id);
        if (input) {
          input.addEventListener('change', () => {
            if (!window.isLoadingCharacter) handler();
          });
        } else {
          console.warn(`Input ${id} not found`);
        }
      });
    } catch (e) {
      console.error('Error initializing page:', e);
      alert('Failed to initialize page.');
    }
  });
</script>
</body>
</html>
```